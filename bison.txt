一个Bison语法文件有四个主要的部分, 就像如下所示,由恰当的分隔符分隔.
%{
	Prologue
%}

	Bison declarations

%%
	Grammar rules

%%
	Epilogue

注释包含在`/* … */'之中,并且可以在任意部分出现. 做为一个GNU扩展,`//'引进了一个直到这行末尾的注释.

Prologue部分包括宏定义和在语法规则动作中使用的函数和变量的声明. 这些将复制到分析器文件的开头以便先于yyparse的定义. 你可以使用`#include'来从头文件获取声明. 如果你不需要任何的C声明,你可以省略这个部分的括号分隔符`%{'和`%}'.

3.1.1 Prologue部分-The prologue
Prologue部分包括宏定义和在语法规则动作中使用的函数和变量的声明. 这些将复制到分析器文件的开头以便先于yyparse的定义. 你可以使用`#include'来从头文件获取声明. 如果你不需要任何的C声明,你可以省略这个部分的括号分隔符`%{'和`%}'.

可以有多个与Bison declarations混合的Prologue部分. 这种做法允许你拥有相互引用的C和Bison声明. 例如,%union可以使用定义在头文件的数据类型, 并且你希望使用带有YYSTYPE类型做为参数的函数. 可以通过两个Prologue块来实现这个, 一个在%union之前,另一个在之后.

	
%{
	  #include <stdio.h>

	  #include "ptypes.h"
%}

	%union {
		  long int n;
		    tree t;  /* tree is defined in `ptypes.h'. */ 
			           /* tree 在`ptypes.h'中定义. */
	}

%{
	  static void print_token_value (FILE *, int, YYSTYPE);
	    #define YYPRINT(F, N, L) print_token_value (F, N, L)
%}


Bison declatations部分包含了定义终结符和非终结符的声明,优先级等等. 在一些简单的语法中,可以不需要任何声明. 

Grammar Rules部分包含了一个或多个Bison语法规则. 参阅 用来表示语法规则的语法-Syntax of Grammar Rules.
在这里至少应该有一个语法规则,并且第一个`%%'(先于语法规则的那个)绝对不能省略,解释它在文件的最开头.

就像Prologue部分被复制到开头一样,Epilogue部分被逐字地复制到分析器文件的结尾. 如果你想放一些代码却没必要放在yyparse的定义之前,这里是最方便的地方. 例如,yylex和yyerror的定义就经常放在这里. 因为C语言要求函数在使用之前必须声明. 你经常需要在Prologue部分声明类似yylex和yyerror的函数, 即使你在Epilogue部分已经定义了它们. 参阅 分析器C语言接口-Parser C-Language Interface.
如果最后一部分为空,你可以省略分隔它的分隔符`%%'.
Bison分析器自己包含了许多以`yy'和`YY'开头宏和标识符的定义. 所以在Epilogue部分避免使用这种类型的名字(出了这个文档讨论的之外)是一个好主意.

Bison语法中的符号(Symbols)代表着语言的语法类型.

一个终结符(terminal symbol)(也被称做符号类型(token type)代表了一类从构造上等价的记号. 你在语法中使用符号的意思就是一个这种类型的记号是允许的. Bison分析器将符号表示为数字码. yylex返回一个记号类型来指明一个被读入的记号是什么类型的. 你不需要了解那个码的数值是多少; 你使用代表它的符号就可以了.

一个非终结符(noterminal symbol)代表一类从构造上等价的组. 符号名称用于编写语法规则. 按照惯例,所有的非终结符都应该是小写的.
符号名称可以是字母,数字(不在开头),下划线和句点. 句点只在非终结符中有意义.

在语法中书写终结符有三种方法:

一个命名符号类型(named token type)用类似C语言的标识符书写. 按照惯例,它们应该是大写字母. 每一个这种名称必须由一个Bison声明%token定义. 参阅 符号类型的名称-Token Type Names.
一个字符记号类型(character token type(或者文字字符记号(literal character token) 用如同C语言字符常量相同的语法书写; 例如,'+'是一个字符记号类型. 除非你要指明字符记号类型的语义值类型(参阅语义值的数据类型-Data Types of Semantic Values一章), 结合性或优先级(参阅操作符优先级-Operator Precedence一章), 否则没有必要声明它们.
按照惯例,一个字符记号类型只用于表示一个由特定字符组成的记号. 因此,记号类型'+'用于将字符`+'表示为一个记号. 没有对此惯例的强制要求, 但是如果你不按照惯例做, 你的程序会使其它的读者感到困惑.
	所有常用的C语言的字符转义序列都可以在Bison中使用, 但是你不能使用一个空字符作为一个字符文字. 因为它的数字码是0,这表示输入结束.(参阅yylex的调用惯例-Calling Convention for yylex一章). 并且,不像标准C 三字符词(trigraphs)(注:由"??"开头的九种转义,为了在缺少标准C标点的宿主上使用标准C,可参考标准C文档) 在Bison中并没有特殊意义并且反斜杠换行也是不允许的.

	一个文字串记号(literal string token)用类似C语言中的字符串常量来书写; 例如,"<="是一个文字串记号. 除非你要指明文字串记号的语义值类型(参阅值类型-Value Type一章), 结合性或优先级(参阅优先级-Precedence一章),你没有必要声明它们.
		你可以使用%token(参阅符号声明-Token Declarations一章)将文字串记号关联一个符号名称作为别名. 如果你不这样做,词法分析器必须从yytname表中重新找到文字串记号的代码. (参阅调用惯例-Calling Convention一章).

	警告: 文字串记号在Yacc中不能工作.

	按照惯例,一个文字串记号只用于表示一个由特定串构成的记号. 因此,你用该使用类型"<="表示作为记号的字符串`<='. Bison并没有强制要求这种管理,但是如果你偏离了惯例, 阅读你程序的人会感到困惑.

				所有常用的C语言的字符转义序列都可以在Bison中使用, 但是你不能使用一个空字符作为一个字符文字. 因为它的数字码是0,这表示输入结束. (参阅 yylex的调用惯例-Calling Convention for yylex.) 并且,不像标准C, 三字符词(trigraphs)(注:由"??"开头的九种转义,为了在缺少标准C标点的宿主上使用标准C,可参考标准C文档) 在Bison中并没有特殊意义并且反斜杠换行也是不允许的. 一个文字串记号必须包括两个或更多个字符; 对于进包含一个字符的记号,你应该使用字符记号(参考以上).

				怎样选择终结符的写法对于它的语法意义没有影响. 它只依赖于它出现在规则的什么地方以及什么时候分器起函数返回那个符号.

				yylex的返回值通常是终结符,除非返回一个代表结束输入的0或者负值. 无论你采用那种方法在语法规则中书写符号类型, 你应该在yylex的定义中采用相同的写法. 单字符符号类型的数字码简单地就是那个字符的正数编码, 所以,即使当char是有符号时你需要将它转换成unsigned char来避免主机上符号扩展 yylex仍可以使用相同的值来产生必要的代码. 每一个命名记号类型在分析器文件中变为一个C宏, 所以yylex可以使用名称代表那个编码. (这就是为什么句点在终结符中不起作用.) 参阅 yylex的调用惯例-Calling Convention for yylex.

				如果yylex是在另外的文件中定义的, 你需要安排符号类型的宏定义在那里是可见的. 在你运行Bison的时候使用`-d'选项 以便让它将这些宏定义写入一个另外的头文件`name.tab.h'. 你可以将它加入其它需要它的文件. 参阅 调用Bison-Invoking Bison.

				如果你要编写一个可以移植到任何标准C宿主上的语法, 你必须只能从基本标准C字符集中选择使用非零字符记号类型. 这个字符集由10个数字,52个大小写英文字母,和在下列C语言字符串中的字符构成的:


		"/a/b/t/n/v/f/r !/"#%&'()*+,-./:;<=>?[//]^_{|}~"
		yylex函数和Bison必须为字符记号使用一个一致的字符集和编码. 例如,如果你在ASCII环境中运行Bison, 但是在不兼容的例如EBCDIC的环境中编译和运行最终的程序, 最终程序可能不会工作.因为Bison产生的表格将字符记号假定为ASCII数字值. 发布带有Bison在ASCII环境中产生的C源文件的软件是标准的做法, 所以在与ASCII不兼容的平台的安装器必须在编译它们之前重新构建这些文件.

		符号error是一个保留用作错误恢复的终结符(参阅错误恢复-Error Recovery一章); 你不应该为了其它的目的而使用它. 特别地,yylex永远不应该返回这个值(注:error). 除非你明确地在声明中赋予一个你的记号值为256,否则error记号的默认值是256.



3.3 描述语法规则的语法-Syntax of Grammar Rules
一个Bison语法规则通常有如下的下形式:

	
result: components…
        ;
		reault所在是这个规则描述的非终结符而components 是被这个规则组合在一起的多种终结符和非终结符.(参阅符号-Symbols一章)

	例如:

		
	exp:      exp '+' exp
	        ;
			表明两组exp类型和一个`+'记号在中间, 可以结合成一个更大的exp类型组.

			规则中的空白只用来分隔符号.你可以在你希望的地方添加额外的空白.

			决定规则的语义的动作可以分散在部件中.一个动组看起来是这样:

				
{C statements}
通常只有一个动作跟随着部件. 参阅 动作-Actions.

result的多种规则可以分别书写或者由垂直条`|'按如下的方法连接起来:

在这种方式下依然有我们之特考虑的特殊规则.

如果一个规则的components为空,它意味着result可以匹配空字符串. 例如,这就是一个定一个由逗号分隔的0个或多个exp组:

	
expseq:   /* empty */ /* 空 */
        | expseq1
		        ;

expseq1:  exp
        | expseq1 ',' exp
		        ;
				我们通常对每个没有部件的规则加上一个`/* empty */'的注释.


ecursive Rules
一个规则被称为递归的(recursive)当它的result非终结符也出现在它的右手边. 因为这种方法是唯一可以定义一个特定事物的任意数字序列的方法, 几乎所有的Bison语法都需要使用递归. 考虑这个逗号分隔的一个或者多个表达式的递归定义:

	
expseq1:  exp
        | expseq1 ',' exp
		        ;
				由于expseq1的递归使用是在有手端的最左符号, 我们称这种递归为左递归(left recursion). 相反地,这里有一个相同地使用右递归(right recursion)的定义.

					
				expseq1:  exp
				        | exp ',' expseq1
						        ;
								任意序列都可以使用作递归或者右递归定义, 但是通常你应该使用左递归, 因为它可以使用空间固定的栈来分析任意个数的元素序列. 由于即使规则只应用一次,在这之前,所有元素也都必须被移进到栈中, 右递归使用的Bison栈空间与序列中的元素个数成正比. 参阅 Bison分析器算法-The Bison Parser Alogorithm.获得这方面的深入解释.

								间接(Indirect)或者相互(mutual)递归当规则的结果没有在它的右手端出现 但是出现在其它右手端的非终结符规则的右手端时候发生.

								例如:

									
								expr:     primary
								        | primary '+' primary
										        ;

primary:  constant
        | '(' expr ')'
		        ;
				定义了两个相互递归的非终结符,因为它们互相引用.


3.5 定义语言的语义-Defining Language Semantics
语言的语法规则之决定了语言的语法. 语义值却是由与多种记号和组相关联的语义值和当各种组被识别时执行的动作决定的.

例如,正是由于对每个表达式关联了正确的数值,计算器才可以正确的计算. 因为组`x + y'的动作是将x和y相关联的值相加, 所以计算器能正确地计算加法
3.5.1 语义值的数据类型-Data Types of Semantic Values
在一个简单的程序中,对所有的语言结构的语义值使用同一个数据类型就足够用了. 在RPN和中缀计算器的例子中的确是这样.(参阅逆波兰记号计算器-Reverse Polish Notation Calculator一章).

Bison默认是对于所有语义值使用int类型. 如果要指明其它的类型,可以像这样将YYSTYPE定义成一个宏:
	
#define YYSTYPE double

3.5.2 多种值类型-More Than One Value Type
在大多数程序中,你需要对不同种类的记号和组使用不同的数据类型. 例如,一个数字常量可能需要类型int或long int, 而一个字符常量可能许需要类型char *, 并且一个标识符需要一个指向符号表项的指针做为其语义值的类型.

为了在一个分析器中使用多种语义值类型, Bison要求你做两件事情:

使用Bison声明%union指明全部可能的数据类型集. (参阅值类型集-The Collections of Value Types一章).
从这些类型中为每个符号(终结符或者非终结符)选择一个做为其语义值类型. 要做到这些,可以对记号使用Bison声明%token(参阅符号类型的名称-Token Type Names一章); 并且对组使用Bison声明%type(参阅非终结符-Nonterminal Symbols一章)


3.5.3 动作-Actions
当一个规则的实例被识别的时候, 同这个规则关联的包含C代码的动作会被执行. 大多数动作是用来从记号的语义值或者更小组的语义值计算整个组的语义值.

一个动作由包含在大括号之内的几个C语句构成,很像一个C语句块. 一个动作可以包含任意数量的C语句. 然而,Bison并不搜索三字符词(trigraphs), 所以如果你的代码中使用了三字符词,你要保证它不影响嵌套的括号或者注释的边界,字符串或单个字符.

一个动作可以安放在规则的任意部分; 它就在那个位置执行. 大多数规则仅有一个在规则所有部件最后的动作. 在规则之中的动作是富有技巧性的并且仅用于特殊的目的 (参阅在规则中间的动作-Actions in Mid-Rule一章).

动作中的C代码可以使用结构$n来引用匹配规则的部件的语义值. 这个结构代表了第n个部件的值. 正在被构建的组的语义值为$$. 当这些被复制到分析器文件的时候,Bison负责将这些结构翻译成适当类型的表达式. $$被翻译成一个可以修改的左值以便可以对它赋值.

这里是一个典型的例子:

	
exp:    …
        | exp '+' exp
		            { $$ = $1 + $3; }
					这个规则从两个由加号连接的稍小的exp组构建一个exp. 在这个动作中,$1和$3代着两个部件exp组的语义值. 它们是规则右手端第一个和第三个符号. 和被存储到$$以便成为刚刚被规则识别的加法表达式的语义值. 如果`+'记号有一个有用的语义值,可以通过$2引用它.

					注意到垂直杠字符`|'的确是一个分隔符, 并且动作只被附加到一个单一的规则上. 这是一点和Flex工具不同的地方. 在Flex中,`|'既代表"或者"也能代表"与下一个规则有着相同的动作". 在下面的例子中,动作仅在`b'被发现的时候触发.

						
					a-or-b: 'a'|'b'   { a_or_b_found = 1; };
如果你并没有指明一个规则的动作,Bison提供了默认的动作: $$ = $1. 因此,第一个符号的值变成了整个规则的值. 当然,仅当它们的数据类型相同时,默认动作才是有效的. 对于一个空规则,并没有有意义的默认动作; 除非这个规则的值无关紧要,否则每个空规则必须有明确的动作.

在$n的n中使用0或负值是允许的. 这使用来引用在匹配当前规则之前的栈中记号或组. 这是一个十分冒险的尝试. 你必须明确当前应用的规则处于的上下文才能可靠地使用它. 这里有一个可靠地使用这种方法的例子:

	
foo:      expr bar '+' expr  { … }
        | expr bar '-' expr  { … }
		        ;

bar:      /* empty */
        { previous_expr = $0; }
		        ;

只要bar仅仅以上面展示的形式使用, $0就总是引用先前于bar的foo的定义中的expr.


3.5.4 动作中值的数据类型-Data Types of Values in Actions
如果你为语义值只选择了一种数据类型, 那么$$和$n结构总是那种类型.

如果你已经使用了%union指定了多种数据类型, 那么你必须从这些类型中为每一个可以有语义值的终结符或非终结符声明一种. 之后当你每次使用$$或者$n的时时侯, 它的数据类型由它引用的符号的类型决定. 在这个例子中:

	
exp:    …
        | exp '+' exp
		            { $$ = $1 + $3; }
					$1和$3引用了exp的实例, 所以它们都有为非终结符exp声明的数据类型. 如果使用了$2,它就会拥有为终结符'+'声明数据类型, 无论它可能是什么.

					另外,在你引用数值的时候, 在引用的开始`$'之后插入`<type>', 你还可以指定数据类型, 例如,如果你已经定义了这里展示的数据类型:

						
					%union {
						  int itype;
						    double dtype;
					}
那么你可以用$<itype>1作为一个整数来引用规则的第一个子单元, 或者用$<dtype>1作为一个双精度数来引用.

3.5.5 规则中的动作-Actions in Mid-Rule
偶尔地,将一个动作放到规则之中是很用用处的. 这些规则的写法如同在规则之后的动作一样, 但是它们却在分析器识别之后的部件之前执行.

一个规则中动作可以通过$n来引用在它之前的部件, 但是不能引用接下来的部件,因为这个动作在它们被分析之前执行.

规则中的动作自己也作为这个规则的一个部件. 这与在同一个规则的另一个动作有些不同(另一个动作通常在结尾): 当在$n使用序号n的时候, 你必须把则个动作和符号一样也计算在内.

																									  规则中的动作也可以拥有语义值. 这个动作可以通过向$$复制来设置它的值, 并且规则之中的后一个动作可应使用$n引用这个值. 由于没有符号可以命名这个动作, 所以没有办法为这个值事先声明一个数据类型. 每当你引用这个值的时候 你必须使用`$<…>n'结构来指明一个数据类型.

																									  没有办法在规则中动作中为整个规则设定一个值, 因为对$$的赋值并没有那个效果(注:看上一段). 为整个规则赋值的唯一方法是通过规则末尾的普通动作实现.

																									  这理有一个来自假想编译器的例子,用于处理let语句. 格式为`let (variable) statement' 并在statement生存期创建一个名为variable的临时变量. 为了分析这个结构, 当statement被分析的时候,我们必须将varible放入符号表, 并在稍后移除它. 这就是这个规则如何工作的:

																										
																									  stmt:   LET '(' var ')'
																									                  { $<context>$ = push_context ();
																														                    declare_variable ($3); }
																																			        stmt    { $$ = $6;
																																						                  pop_context ($<context>5); }
																																										  一旦`let (variable)'已经被识别,第一个动作就执行. 它使用了数据类型联合中的context, 并保存了一个当前语义上下文(可访问变量列表)的副本作为它的语义值. 然后调用declare_variable来向那个列表添加新的变量. 一旦第一个动作执行完毕, 嵌入的语句stmt就可以被分析了. 注意到规则中动作的编号是5,所以`stmt'的编号为6.

																																										  在嵌入的语句stmt被分析之后,它的语义值边变为了整个let-语句的值.(注:$$=$6;) 之后,前一个动作的语义值(注$<context>5)被用来存储先前的变量列表.(注:pop_context ($<context>5)) 这将临时的let-变量从列表中删除. 这样作的目的是让它不出现在分析程序的其余部分的时候.

																																										  由于分析器为了执行动作而进行强制分析, 在一个规则没有完全被识别之前执行动作经常会导致冲突. 例如,如下的两个规则,并没有规则中的动作,可以在分析器中共存. 因为分析器可以移进一个左大括号 并且查看之后跟随的符号来确定这是否是一个声明.

																																											
																																										  compound: '{' declarations statements '}'
																																										          | '{' statements '}'
																																												          ;
																																														  但是当我们向下面这样添加一个规则中的动作时,规则就失效了:

																																															
																																														  compound: { prepare_for_local_variables (); }
																																														            '{' declarations statements '}'
																																																	        | '{' statements '}'
																																																			        ;
																																																					现在,当分析器还没有读到左到括号的时候,它就被迫决定是否执行规则中的动作. 换句话说,当分析器没有足够的信息作出正确选择的时候, 它就会强制使用一个或者其它的规则. (这个时候由于分析器仍在决定怎么办, 左大括号记号被称之为超前扫描记号(look-ahead). 参阅 超前扫描记号-Look-Ahead Token.) (注:这个时候两个规则的超前扫描记号都是`{')

																																																						你可能认为给这两个规则放置相同的动作可以解决这个问题,就像这样:

																																																								
																																																							compound: { prepare_for_local_variables (); }
																																																						          '{' declarations statements '}'
																																																									          | { prepare_for_local_variables (); }
																																																								            '{' statements '}'
																																																												        ;
																																																											但是这种方法不可行,因为Bison并没有意识到两个动作是完全相同的. (Bison永远不会尝试理解动作中的C代码.)

																																																												如果语法是这样的:可以依靠第一个记号(C语言就是这样)识别出一个声明. 那么将动作放到左大括号后是一个可行的解决方法. 就像这样:

																																																													
																																																												compound: '{' { prepare_for_local_variables (); }
																																																											          declarations statements '}'
																																																														          | '{' statements '}'
																																																																          ;
																																																													  现在接下来的声明或者语句的第一个记号(注:超前扫描记号) 在任何情况下都会告知Bison该使用哪一个规则.

																																																														  另外一种解决方法是将动作放入一个做为子规则的非终结符.

																																																															
																																																														  subroutine: /* empty */
																																																														            { prepare_for_local_variables (); }
																																																													          ;


compound: subroutine
			            '{' declarations statements '}'
						        | subroutine
								          '{' statements '}'
										          ;
		  现在Bison不用却确定最终使用的规则就可执行规则subroutine中的动作. 注意到:现在动作已经在规则的结尾. 任何规则中间的动作都可以由这种方法转化为一个规则结尾的动作, 并且这也是Bison处理规则中间的动作的方法.


4.2.1 yylex的调用惯例-Calling Convention for yylex
yylex的返回值必须是它刚刚发现的记号类型的正值数字码; 0或负值代表着输入的结束.

当一个记号在语法规则中由它的名称引用时, 这个名称在语法文件中是一个宏, 这个宏定义了那个记号类型的恰当的数字码. 所以yylex可是使用这个名称来指明那个记号类型. 参阅 符号-Symbols.

当一个记号在语法文件中由一个字符引用时, 那个字符的数字码同样也是那个记号类型的数字码. 所以yylex可以简单地返回那个字符码, 并且可能转换为unsigned char以避免符号扩展. 但空字符绝对不能这样使用, 因为它的数字吗为0, 这意味这输入的结束.

这里是一个展示这些东西的例子:

 	
int
yylex (void)
{
		  …
				    if (c == EOF)    /* Detect end-of-input.  */ /* 检测到输入结束 */
							    return 0;
		    …
					  if (c == '+' || c == '-')
							      return c;      /* Assume token type for `+' is '+'.  */ /* 认定`+'的记号类型就是'+' */
			  …

					    return INT;      /* Return the type of the token.  */ /* 返回记号的类型 */
			    …
}
设计这种接口的目的是为了可以不加更改地使用lex工具的输出yylex.

如果语法使用了文字串记号, yylex决定记号类型马的方法有两种:

如果语法定义了文字串记号的符号名称别名, yylex可以像其它符号名称一样使用这些符号名称. 这种情况下, 语法文件中使用文字串记号对yylex没有影响.
yylex可以在yytname表中找到多字符记号. 这个记号的索引是这个记号的类型码. 多字符记号的名称由一个双引号,记号的字符和另外一个双引号记录在yytname中. 无论如何,记号(注:多字符记号)的字符不能是转义的; 它一字不差地出现在表格字符串的内容里.
这里有在yytname中搜索记号的代码. 这个代码假定记号的字符存储在token_buffer中.


for (i = 0; i < YYNTOKENS; i++)
{
		if (yytname[i] != 0
						&& yytname[i][0] == '"'
						&& ! strncmp (yytname[i] + 1, token_buffer,
								strlen (token_buffer))
						&& yytname[i][strlen (token_buffer) + 1] == '"'
						&& yytname[i][strlen (token_buffer) + 2] == 0)
				break;
}
yytname表格只在你使用了%token-table声明才会生成. 参阅 声明总结-Decl Summary.

4.2.2 记号的语义值-Semantic Values of Tokens
在一个普通的(不可重入)的分析器中, 记号的语义值必须被存放在全局变量yylval中. 当你只使用一种语义值数据类型时, yylval就是那个类型. 因此,如果类型为int(默认的), 你可以这样编写你的yylex:

 	
  …
    yylval = value;  /* Put value onto Bison stack.  */ /* 将值放入Bison栈中 */
	  return INT;      /* Return the type of the token.  */ /* 返回记号类型 */
	    …
		当你使用多种数据类型时, yylval的类型是一个由%union声明组成的联合体. (参阅值类型集-The Collections of Value Types一章). 所以,当你存储一个记号的语义值的时候, 你必须使用恰当的联合体成员. 如果%union声明是这样的:

		 	
		%union {
				  int intval;
				    double val;
					  symrec *tptr;
		}
那么yylex中的代码应该是这样:


…
yylval.intval = value; /* Put value onto Bison stack.  */ /* 将值放入Bison栈中. */
return INT;            /* Return the type of the token.  */ /* 返回记号的类型 */
…



4.2.3 记号的文字位置-Textual Locations of Tokens
如果你在动作中使用了`@n'-特征(参阅追踪位置-Tracking Locations一章)来追踪记号和组的文字位置, 那么你必须在yylex中提供这些信息. yyparse预期在全局变量yyloc中找到刚刚分析的记号的文字位置. 所以yylex必须在那个变量里存放正确的数据.

默认地,yyloc的值是一个结构体并且你只需要初始化将被动作使用的成员. 四个成员分别是first_line, first_column, last_line和 last_column. 注意到:使用这个特征会使分析器的性能显著下降.

yyloc的数据类型为YYLTYPE.

4.2.4 纯分析器的调用惯例-Conventions for Pure Parsers
当你使用Bison声明%pure-parser要求得到一个纯,可重入的分析器, 全局通信变量yylval和yylloc不能继续使用. (参阅 一个纯(可重入)分析器-A Pure (Reentrant Parser.) 在这种分析器中,两个全局变量由传递给yylex的指针参数取代. 你必须如下你声明它们,并通过这些指针存储数据最后将它们传回.

				 	
				int
				yylex (YYSTYPE *lvalp, YYLTYPE *llocp)
				{
				  …
				    *lvalp = value;  /* Put value onto Bison stack.  */ /* 将值放入Bison栈 */
					  return INT;      /* Return the type of the token.  */ /* 返回记号类型 */
					    …
						}
						如果语法们文件没有使用`@'结构引用文字位置, 那么类型YYLTYPE就不会被定义. 在这种情况下,省略第二个参数; 仅用一个参数调用yylex.

						如果你希望传递额外的数据到yylex, 可以是用%lex-param,就像%parse-param一样 (参阅分析器函数-Parser Function一章).

						指令: lex-param {argument-declaration}
						声明argument-declaration是一个额外的yylex参数.

						例如:

						 	
%parse-param {int *nastiness}
%lex-param   {int *nastiness}
%parse-param {int *randomness}
导致了如下的结果:

 	
int yylex   (int *nastiness);
int yyparse (int *nastiness, int *randomness);
如果添加了%pure-parser:

 	
int yylex   (YYSTYPE *lvalp, int *nastiness);
int yyparse (int *nastiness, int *randomness);
最后,如果%pure-parser和%locations都被使用:

 	
int yylex   (YYSTYPE *lvalp, YYLTYPE *llocp, int *nastiness);
int yyparse (int *nastiness, int *randomness);

4.3 错误报告函数yyerror-The Error Reporting Function yyerror
Bison分析器侦测到一个语法错误(syntax error) 或者一个分析错误(parse error) 每当它读入了一个不能满足任何规则的记号. 一个语法动作也可以使用宏YYERROR显式地声明一个错误 (参阅使用动作的特殊特征-Special Features for Use in Actions一章).

Bison分析器期望靠调用一个名为yyerror的错误处理报告函数报告错误. 这个函数必须由你提供. 每当yyparse发现一个语法错误的时候, yyparse就会调用它. yyparse只接受一个参数. 对于一个语法错误, 显示的字符串通常是"syntax error".

如果你在Bison declarations部分 (参阅Bison Declarations部分-The Bison Declarations Section一章) 使用了%error-verbose指令, 那么Bison会提供更加详细而明确的错误信息而不是仅有"syntax error".

分析器可以侦测到另外一种错误:栈溢出. 这在输入包含非常深层次的嵌套结构时发生. 你很难遇到这种情况, 因为Bison会自动将栈容量扩展到一个很大的极限. 但是如果溢出发生, yyparse会以通常的格式调用yyerror并带有字符串"parser stack overflow".

下面的定义对于简单的程序足够用了:

 	
void
yyerror (char const *s)
{
		  fprintf (stderr, "%s/n", s);
}
当yyerror返回到yyparse后, 如果你以已经写好了恰当的错误恢复语法规则(参阅错误恢复-Error Recovery一章), yyparse会尝试进行错误恢复. 如果恢复是不可能的,yyparse会立即返回1.

显然,在带有错误追踪的纯分析器中, yyerror应该会访问当前的位置. 由于历史原因,这些的确是GLR分析器的事情而不是Yacc分析器的事情. 例如,如果传递了`%locations %pure-parser',那么yyerror的原型是:

 	
void yyerror (char const *msg);                 /* Yacc parsers.  */ /* Yacc 分析器 */
void yyerror (YYLTYPE *locp, char const *msg);  /* GLR parsers.   */ /* GLR 分析器 */
如果使用了`%parse-param {int *nastiness}',那么原型是:

 	
void yyerror (int *nastiness, char const *msg);  /* Yacc parsers.  */ /* Yacc 分析器 */
void yyerror (int *nastiness, char const *msg);  /* GLR parsers.   */ /* GLR 分析器 */
最终,GLR和Yacc分析器对绝对的纯分析器共享相同的yyerror调用惯例, 例如,当yylex和%pure-parse的调用惯例是纯调用,例如:

 	
/* Location tracking.  */ /* 追踪位置 */
%locations
/* Pure yylex.  */ /* 纯yylex */
%pure-parser
%lex-param   {int *nastiness}
/* Pure yyparse.  */ /* 纯yyparse */
%parse-param {int *nastiness}
%parse-param {int *randomness}

导致了如下用于所有种类分析器的原型:

 	
int yylex (YYSTYPE *lvalp, YYLTYPE *llocp, int *nastiness);
int yyparse (int *nastiness, int *randomness);
void yyerror (YYLTYPE *locp,
				              int *nastiness, int *randomness,
							                char const *msg);
原型只是用来指明Bison产生的代码如何使用yyerror. Bison产生的代码通常忽略返回值, 所以yyerror可以返回任何类型, 包括void. 并且yyerror可以是一个变参函数(variadic funcation), 这就是为什么消息总在最后传递的原因.

yyerror在传统上返回一个经常被忽略的int, 但这仅仅出于纯历史的原因. void是更好的选择, 因为它更精确的反应了yyerror的返回类型.

变量yynerrs包含了到目前位置遭遇的语法错误的数量. 这个变量通常是全局的; 但是如果你要求一个纯分析器(参阅一个纯(可重入)分析器-A Pure (Reentrant) Parser一章), 那么这个变量就是一个只能被动作访问的局部变量.


4.4 在动作中使用的特殊特征-Special Features for Use in Actions
这里是在动作中使用的Bison结构,变量和红的列表.

变量: $$
像一个变量一样工作,这个变量包含了由当前规则构成的组的语义值. 参阅 动作-Actions.

变量: $n
像一个变量一样工作,这个变量包含了当前动作第n个部件的语义值. 参阅 动作-Actions.

变量: $<typealt>$
类似$$但是指明了%union声明中的typealt选项. 参阅 动作中值的数据类型-Data Types of Values in Actions.

变量: $<typealt>n
类似$n但是指明%union声明中的typealt选项. 参阅 动作中值的数据类型-Data Types of Values in Actions.

宏: YYABORT;
立即从yyparse返回,表明分析失败. 参阅 分析器函数yyparse-The Parser Function yyparse.

宏: YYACCEPT;
立即从yyparse返回,表明分析成功. 参阅 分析器函数yyparse-The Parser Function yyparse.

宏: YYBACKUP (token, value);
移出一个记号. 这个宏仅仅在一个只归约单一值的规则中使用,并且只在没有超前扫描记号的时候被允许使用. 这个宏也不允许在GLR分析器中使用. 这个宏建立一个超前带有记号类型token和语义值value的超前扫描记号; 然后丢弃将要被这个规则归约的值.

如果这个宏在无效的情况下使用, 例如当已经存在超前扫描记号的情况下使用, 那么它会报告一个带有消息`cannot back up'的语法错误 并且执行一个普通的错误恢复程序.

在上述任一种情况下,动作的其余部分不会被执行.

宏: YYEMPTY
当没有超前扫描记号的时候,值被存放在yychar中.

宏: YYERROR;
立即导致一个语法错误. 这个语句启动错误恢复就像分析器自己已经侦测到一个错误一样; 然而,它并不调用yyerror并且不打印任何消息. 如果你要打印一个错误消息, 在`YYERROR;'语句之前显式地调用yyerror. 参阅 错误恢复-Error Recovery.

宏: YYRECOVERING
当分析器从语法错误中恢复的时候,这个表达式的值为1. 其余时候值为0. 参阅 错误恢复-Error Recovery.

变量: yychar
包含当前超前扫描记号的变量. (在一个纯分析器中,这实际上是一个yyparse中的局部变量). 当没有超前扫描记号的时候,这个变量存储YYEMPTY的值. 参阅 超前扫描记号-Look-Ahead Tokens.

宏: yyclearin;
丢弃当前的超前扫描记号. 它主要用于错误恢复规则. 参阅 错误恢复-Error Recovery.

宏: yyerrok;
对后来的语法错误立即恢复产生错误消息. 它主要用于错误恢复规则. 参阅 错误恢复-Error Recovery.

值: @$
像一个包含文字位置信息的结构一样工作. 这个位置是由当前规则构成的组的位置. 参阅 追踪位置-Tracking Locations.

值: @n
像一个包含文字位置信息的结构一样工作. 这个位置是由当前规则的第n个部件的位置. 参阅 追踪位置-Tracking Locations.



5. Bison分析器算法-The Bison Parser Algorithm
当Bison读取记号的时候,它将这些记号同它们的语义值一起压入栈中. 这个栈被称为分析器栈(parser stack). 将一个记号压入栈在传统上被称为移进(shifting).

例如,假设中缀计算器已经读取`1 + 5 *'并且将要读取`3'. 分析器栈此时有四个元素,每个元素对应一个被移进的符号.

但是这个栈并不是总含有每个被读入记号的元素. 当最后n个被移进的记号和组匹配语法规则部件时, 可以由那个规则将它们结合起来. 这叫做归约(reduction). 这些栈中的记号和组被一个单一的组取代. 那个组的符号是这个规则的结果(左手端). 运行规则的动作是处理归约的一部分, 因为这就是什么在计算结果组的语义值.

例如,如果中缀计算器的分析器栈包含这个:

 	
1 + 5 * 3
并且下一个输入是一个换行符, 那么最后三个元素可通过这个规则被归约成15:

 	
expr: expr '*' expr;
那么这个栈仅含有三个元素:

 	
1 + 15
在整个时候可以进行另外一个结果为16的归约. 然后,换行符记号才可以被移进.

分析器通过移进和归约尝试将整个输入化为一个符号为语法开始符号的单一组. (参阅语言与上下文无关文法-Languages and Context-Free Grammars一章).

这种类型的分析器被称之为自底向上(bottom-up)的分析器.


5.1 超前扫描记号-Look-Ahead Tokens
Bison分析器并不总是在最后n个记号和组匹配一个规则时立即进行归约. 这是由于这种策略对于处理大多数语言来说是不够的. 相反,当可以进行一个归约的时候, 分析器有时"超前扫描"下一个记号来决定该怎么做.

当读取一个记号时, 它并不是被马上移进而是首先成为不在栈中的超前扫描记号(look-ahead token). 现在分析器可以对记号和组进行一个或更多的归约,而超前扫描记号仍在栈外. 这并不意味着所有可能的归约已经执行; 依赖于超前扫描记号的符号类型, 一些规则可以选择推迟它们的应用.

这里有一个需要超前扫描记号的例子. 这三个规则定义了包括二进制加法操作符和一元后缀阶称操作符(`!'), 并且允许括弧分组.

 	
expr:     term '+' expr
        | term
		        ;

term:     '(' expr ')'
        | term '!'
		        | NUMBER
				        ;
						假定`1 + 2'已经被读取和移进; 分析器这时应该做什么? 如果接下来的记号是`)', 那么前三个记号必须被归约成一个expr. 这是唯一有效的情况, 因为移进`)'会产生一系列的term ')', 而没有规则允许这样.

						如果接下来的符号是`!', 那么它必须马上被移进以便`2 !'可以被移进产生一个term. 如果不这样做, 分析器将会在移进之前进行归约, `1+2'会成为一个expr. 那是移进`!'就是不可能的, 因为这么做会使栈中产生序列expr '!'. 没有规则允许那样的序列.

						当前的超前扫描记号被存储在yychar中. 参阅 在动作中使用的特殊特征-Special Features for Use in Actions.


						5.2 移进/归约冲突-Shift/Reduce Conflicts
						假设我们正在分析一个有if-then和if-then-else语句的语言 并且这个语言带有如下一对规则:

						 	
						if_stmt:
						          IF expr THEN stmt
								          | IF expr THEN stmt ELSE stmt
										          ;
												  这里我们假定IF,THEN和ELSE是用来指定关键字的终结符.

												  当ELSE被读入成为超前扫描记号, 栈中的内容(假定输入是有效的)刚好可以由第一个规则进行归约. 但是移进ELSE也是合法的, 因为这最终将会导致由第二个规则进行的归约.

												  这种情况,移进或者归约都是有效的,被称为移进/归约冲突(shift/reduce conflict). Bison被设计成选择移进来解决这些冲突, 除非有其它的操作符优先级的指导. 为了研究这样做得原因, 我们将它和另一种选择(注:选择归约)做一个对比.

												  由于分析器选择移进ELSE. 这样作的结果是将else从句依附到最里面的if语句中, 并使下面两个输入在作用上等价.

												   	
												  if x then if y then win (); else lose;

												  if x then do; if y then win (); else lose; end;
												  但如如果分析器选择在可能的时候归约而不是移进. 这样做的结果是将else从句依附到最外面的if语句中, 并使下面两个输入在作用上等价:

												   	
												  if x then if y then win (); else lose;

												  if x then do; if y then win (); end; else lose;
												  冲突存在的原因是由于语法本身有歧义: 任一种简单的if语句嵌套的分析都是合法的. 已经建立的惯例是通过将else从句依附到最里面的if语句来解决歧义; 这就是Bison为什么选择移进而不是归约的原因. (在理想的情况下,最好编写一个非歧义的文法, 但是在这种情况下却很难办到.) 这种特殊的歧义在Algol 60的描述中首次出现并被成为"悬挂else"歧义.

												  为了避免Bison警告那些可以预见的合法的移进/归约冲突, 我们可以使用%expect n声明. 当移进/归约冲突的数目恰好是n的时候, Bison不会做出任何警告. 参阅 消除冲突警告-Suppressing Conflict Warnings.

												  有人抱怨上面if_stmt的定义, 但是冲突的确实在没有任何额外规则的时候出现. 这又一个完整的体现这个冲突的Bison输入文件:

												   	
 %token IF THEN ELSE variable
  %%
  stmt:     expr
  | if_stmt
  ;

if_stmt:
IF expr THEN stmt
| IF expr THEN stmt ELSE stmt
;

expr:     variable
;


5.3 操作符优先级-Operator Precedence
移进/归约冲突也可能出现在算术表达式中. 在这里,移进并不总是优先的选择; Bison关于操作符优先级的声明允许你指定什么时候移进和什么时候归约.

5.3.1 什么时候需要优先级-When Precedence is Needed
考虑下面的歧义文法片段 (产生歧义的原因是输入`1 - 2 * 3'可以由两种方法进行分析):


		expr:     expr '-' expr
		| expr '*' expr
		| expr '<' expr
		| '(' expr ')'
		…
										        ;
												假设分析器已经读入了记号`1',`-'和`2'; 那么它是否应该使用减法操作符规则进行归约呢? 这依赖于下一个记号. 当然,如果下一个记号是`)',我们必须归约, 由于没有规则可以归约`- 2 )'或者以它开始的记号序列, 所以移进是无效的. 但是如果下一个符号是`*'或者`<', 我么有了一个选择: 移进和归约都可以,但是会产生不同的结果.

												要决定Bison应该怎么做,我们必须考虑结果. 如果下一个操作符记号op被移进, 那么它必须首先被归约以便允许进行另外一个归约的机会. 结果为`1 - (2 op 3)'. 另一方面,如果在移进op之前归约减法, 结果为`(1 - 2) op 3'. 很明显,选择移进或者归约依靠操作符`-'和op的相对优先级: `*'是该首先被移进,而不是`<'.

												当输入为`1 - 2 - 5'的时候会怎么样, 这应该是`(1 - 2) - 5'还是`1 - (2 - 5)'? 对于大多数操作符来说,我们选择前者. 这被成为左结合(left association). 后面一种,右结合(right association), 对于赋值操作符是理想的选择. 选择左结合或者有结合是 当栈包含`1 - 2'并且超前扫描记号是`-'时,分析器选择移进还是归约的问题: 移进代表着右结合.

5.3.2 指定操作符的优先级-Specifying Operator Precedence
Bison允许你使用操作符优先级声明%left和%right指定这些选择. 每一个这样的声明包含了一个要声明其优先级和结合性的记号列表. %left声明使这些操作符成为左结合的, %right声明使这些操作符成为右结合的. 第三种选择是%nonassoc,它声明了 "在一行中"有两个相同的操作符是一个语法错误.

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
不同操作符的优先级由它们声明的顺序控制. 文件中的第一个%left或者%right声明的优先级最低, 下一个类似声明的操作符有稍高的优先级,以此类推.

5.3.3 优先级使用的例子-Precedence Examples
在我们的例子中,我们会发现下面的声明:

%left '<'
%left '-'
%left '*'
在一个支持其它操作符的更完整的例子中, 我们会成组地声明具有相同优先级的操作符. 例如'+'和'-'一起声明.

%left '<' '>' '=' NE LE GE
%left '+' '-'
%left '*' '/'

(在这里NE代表着"不相等"操作符",其它以此类推. 我们假定这些记号的长度多于一个字符并且因此由它们的名字代表而不是字符.)

5.3.4 优先级如何工作-How Precedence Works
优先级声明的第一个作用是赋予声明的终结符以优先级. 第二个作用是赋予特定的规则以优先级: 每个规则从部件中最后一个提及的终结符中获取优先级. (你也可以明确的指明规则的优先级. 参阅 上下文依赖优先级-Context-Dependent Precedence.)

		最终,解决中冲突的方法是比较正在考虑的规则和超前扫描记号的优先级. 如果超前扫描记号的优先级更高,那么选择移进. 如果规则的优先级更高,那么选择归约. 如果它们有相同的优先级, 那么靠那个优先级的结合性来作出选择. 由选项`-v'(参阅调用Bison-Invoking Bison一章)制造的冗长的输出文件(The verbose output file) 说明了每个冲突是如何解决的.

		并不是所有的规则和记号都有优先级. 如果规则和超前扫描记号都没有优先级, 那么默认的动作是移进.

		5.4 上下文依赖优先级-Context-Dependent Precedence
		一个操作符的优先级通常依赖于上下文. 这最开始听起来很古怪,但它的确很常见. 例如,典型地,一个负号操作符有比一元操作符更高的优先级 并且比二进制操作符的优先级稍低(低于乘法).

		Bison优先级声明,%left,%right和%nonassoc 对于一个给定的操作符只能使用一次; 所以通过这种方法,一个操作符只能有一种优先级. 对于上下文依赖优先级来说,你需要使用一种额外的机制: 规则的%prec修饰符.

		%prec靠指定用于那个规则终结符的优先级来声明特定规则的优先级. 那个符号不需要以特殊的方式出现在规则中. 修饰符的语法为:

		 	
		%prec terminal-symbol
		并且它写在规则的部件之后. 它的作用是赋予规则terminal-symbol的优先级而不考虑从普通方法推导出的优先级. 被改变的规则优先级会影响包含那个规则的冲突的解决方法. (参阅操作符优先级-Operator Precedence一章).

		这是%prec如何解决负号问题的例子. 首先为一个虚构的名为MINUS的终结符声明优先级. 实际上没有记号是这种类型, 但是这个符号以它自己的优先级来使用.

		 	
		…
		%left '+' '-'
		%left '*'
		%left UMINUS
		现在可以在规则中使用MINUS的优先级.


		exp:    …
		| exp '-' exp
		…

		| '-' exp %prec UMINUS

5.4 上下文依赖优先级-Context-Dependent Precedence
一个操作符的优先级通常依赖于上下文. 这最开始听起来很古怪,但它的确很常见. 例如,典型地,一个负号操作符有比一元操作符更高的优先级 并且比二进制操作符的优先级稍低(低于乘法).

Bison优先级声明,%left,%right和%nonassoc 对于一个给定的操作符只能使用一次; 所以通过这种方法,一个操作符只能有一种优先级. 对于上下文依赖优先级来说,你需要使用一种额外的机制: 规则的%prec修饰符.

%prec靠指定用于那个规则终结符的优先级来声明特定规则的优先级. 那个符号不需要以特殊的方式出现在规则中. 修饰符的语法为:

 	
%prec terminal-symbol
并且它写在规则的部件之后. 它的作用是赋予规则terminal-symbol的优先级而不考虑从普通方法推导出的优先级. 被改变的规则优先级会影响包含那个规则的冲突的解决方法. (参阅操作符优先级-Operator Precedence一章).

这是%prec如何解决负号问题的例子. 首先为一个虚构的名为MINUS的终结符声明优先级. 实际上没有记号是这种类型, 但是这个符号以它自己的优先级来使用.

 	
…
%left '+' '-'
%left '*'
%left UMINUS
现在可以在规则中使用MINUS的优先级.
exp:    …
| exp '-' exp
…

| '-' exp %prec UMINUS





rser States
函数yyparse是使用有限状态机(finite-state-machine)来实现的. 压入分析器栈中的值不仅仅是符号类型码; 它们代表了整个在栈顶或者靠近栈顶的终结符和非终结符序列. 当前的状态收集了与决定下一步怎么做相关的之前输入的信息.

每次读入一个超前扫描记号, 分析器就在一个表中搜索分析装当前状态和超前扫描记号类型. 这个表项能会说"移进超前扫描记号" 在这种情况下,它在指定了一个新的分析器状态的同时将这个状态压入栈顶. 或者,它(注:指表项)也可能说"使用第n个规则进行归约." 这意味着某些个数的记号合组被移出栈,取而代之的是一个组. 用另外一种说法, 那些个数(注:n)的状态被弹出栈,一个新状态被压入栈.

还有另外一种选择:这个表可能会说那个超前扫描记号在当前的状态下是错误的. 这会引发错误处理.(参阅错误恢复-Error Recovery一章).

5.6 归约/归约冲突-Reduce/Reduce Conflicts
一个归约/归约冲突发生在有两个或者更多规则可以被用于相同输入序列的情况下. 这通常表明了一个语法中的严重错误.

例如,这里是一个试图定义零个或者更多word组的错误.

 	
sequence: /* empty */
                { printf ("empty sequence/n"); }
				        | maybeword
						        | sequence word
								                { printf ("added word %s/n", $2); }
												        ;

maybeword: /* empty */
                { printf ("empty maybeword/n"); }
				        | word
						                { printf ("single word %s/n", $1); }
										        ;
这个错误是一个歧义:有多种方法可以将单一的word分析成一个sequence. 它可以归约为一个maybeword然后通过第二个规则归约为一个sequence. 另外,什么都没有可以通过第一个规则归约为一个sequence, 可以使用sequence的第三个规则将它和word结合起来.

也有多种方法将什么都没有归约成一个sequence. 可以直接通过第一个规则归约或者间接通过maybeword然后通过第二个规则归约.

你可能认为这没有什么区别, 因为不论任意的输入是否有效它没有什么变化. 但是它却影响这该执行哪一条规则. 一种分析顺序运行了第二个规则的动作, 另一个则运行了第一个和第三个规则的动作. 在这个例子中,程序的输出有所变化.

Bison靠选择首先出现在语法中的规则解决归约/归约冲突, 但是依靠这种策略是十分冒险的事情. 必须仔细研究每一个归约/归约冲突并且通常要消灭它们. 这里有一个正确定义sequence的方法:

 	
sequence: /* empty */
                { printf ("empty sequence/n"); }
				        | sequence word
						                { printf ("added word %s/n", $2); }
										        ;

这里是另外一个产生归约/归约冲突的普通例子:

 	
sequence: /* empty */
        | sequence words
		        | sequence redirects
				        ;

words:    /* empty */
        | words word
		        ;

redirects:/* empty */
        | redirects redirect
		        ;
				这里的目的是定一个可以包含word或redirect组的序列. sequence,words和redirects的定义都是没有问题的, 但是三个在一起却产生微妙的歧义: 即使一个空输入可以有无限多种分析的方式.

				考虑:什么都没有可以是一个words. 或者它可以是两个在一行的words,或者三个,或者任意个. 它同样也可以是一个words后跟三个redirects和另外一个words. 等等.

				这有两种改正这些规则的方法. 第一,使它成为一个单层序列:

				 	
				sequence: /* empty */
				        | sequence word
						        | sequence redirect
								        ;
										第二,防止words或者redirects为空:


										sequence: /* empty */
										| sequence words
										| sequence redirects
										;

words:    word
| words word
;

redirects:redirect
| redirects redirect
;


5.7 神秘的归约/归约冲突-Mysterious Reduce/Reduce Conflicts
[untranslated] Sometimes reduce/reduce conflicts can occur that don't look warranted. [/untranslated] 这里有一个例子:

 	
%token ID

%%
def:    param_spec return_spec ','
        ;
param_spec:
             type
			         |    name_list ':' type
					         ;
return_spec:
             type
			         |    name ':' type
					         ;
type:        ID
        ;
name:        ID
        ;
name_list:
             name
			         |    name ',' name_list
					         ;
							 这个文法看起来可以用一个单一的超前扫描记号分析: 当正在读入para_spec的时候. 如果ID后面紧跟一个分号,那么它是一个name. 如果ID后面跟随另外一个ID,那么它是一个type. 换句话说,这是一个LR(1)文法.

							 然而,像大多数分析器产生器一样,Bison实际上并不能处理所有的LR(1)文法. 在这个文法中,两个位于param_spec的开始,并同样地位于return_spec开始 ,在ID之后的上下文十分相似,以致于Bison认为它们是相同的. 它们看起来相似因为相同的规则集是活动的--归约到name的规则和归约到type的规则. Bison在那个处理阶段没有能力决定这些规则在两个上下文中需要不同的超前扫描记号, 所以它为两种情况制造了同一个分析器状态. 结合两个上下文会在稍后引起一个冲突. 在分析器术语中, 这种情况意味着这个文法不是LALR(1)文法.

							 通常来讲,最好是修补漏洞而不是将漏洞写入文档. 但是这个特殊的漏洞很难被修复; 处理LR(1)文法的分析器生成器很难编写并且倾向于制造很大的分析器. 在实践中,Bison显得更为实用.

							 当问题产生时, 你通常可以通过指明两个被混淆的分析器状态 并且添加使它们看起来截然不同的额外的东西 来修补它, 在上面的例子中, 如下地向return_spec添加一个规则会消除这个问题:

							  	
							 %token BOGUS
							 …
							 %%
							 …
							 return_spec:
							              type
										          |    name ':' type
												          /* This rule is never used.  */ /*  这个规则永远不会被使用 */
												          |    ID BOGUS
														          ;
																  这样做改正这个问题, 因为在return_spec开始部分ID后的上下文中引进了一个可能的额外的活动规则. 这个规则在param_spec相应的上下文中并不是活动的, 所以两个上下文接受了不同的分析器状态. 只要yylex永远不产生记号BOGUS, 新增的规则就不能改变分析输入的实际方法.

																  在这个特殊的例子中,还有另外一种解决问题的方法: 直接使用使用ID来替代name来重写return_spec的规则. 这样做也使两个混淆的上下文有了不同的活动集, 因为return_spec的活动集激活了return_spec的规则而不是name的.

																   	
																  param_spec:
																  type
																  |    name_list ':' type
																  ;
return_spec:
type
|    ID ':' type
;

5.8 通用LR (GLR)分析-Generalized LR (GLR) Parsing
Bison产生确定性(determinstic)的分析器. 这种分析器基于先前输入和额外的超前扫描记号的摘要, 唯一性地选择进行归约的时机和如何进行归约. 结果,通常,Bison处理一个上下文无关文法语言族的自己. 由于歧义文法含有可以使用多种可能的归约序列的字符串, 所以在这种情况下不能使用确定的分析器. 这种情况同样适用于需要多于一个超前扫描记号的语言, 因为分析器缺乏做出决定所需要的必要信息, 这时它必须被制作成一个移进-归约分析器. 最终,如同之前提到的(参阅神秘的冲突-Mystery Conflicts一章), 有这样一些语言,Bison关于如何总结输入的特殊选择目前看起来缺少必要的信息.

当你在你的语法文件中使用`%glr-parser'声明的时候, Bison产生一个使用不同算法的分析器,这种分析器被称为通用LR(或GLR)分析器. 一个Bison GLR分析器使用同样基本的算法做为一个普通的Bison分析器进行分析, 但当存在一个不能被优先级规则(参阅优先级-Precedence一章)解决的移进/归约冲突, 或者一个归约/归约冲突时却有着与普通Bison分析器不同的行为. 当一个GLR分析器遭遇这种情况的时候, 它高效地分裂(splits)成多个分析器, 每个对应一种可能的移进或者归约. 这些分析器如常地进行分析,使用锁步(lock-step)消耗记号. 一些栈遭遇了其它的冲突并且进一步分裂, 一个Bison GLR分析栈是一个取代状态序列的高效的分析树.

实际上,每个栈代表一个关于正确分析的猜想. 剩余的输入可能会表明一个猜想是错误的, 在这种情况下,不正确的栈静静地消失. 另外,每个栈中的语义动作被保存而不是立即执行. 但一个栈消失时,它存储的的语义动作永远不会被执行. 当一个归约使两个栈等价的时候, 它们的语义动作集和导致归约的状态都会被保存. 我们说两个栈是等价的 当它们都代表相同的状态序列, 并且每对相应的状态代表一个产生相同输入流片段的语法符号.

每当分析器从有多个分析状态转换为一个分析状态时, 在执行了原来保存的动作后, 这个分析器将转变到通常的LALR(1)分析算法. 在这个转换过程中,一些栈上的状态含有可能的动作集(实际上是多个集)的语义值. 分析器试图从这些动作中挑选一个被`%prec'声明指定的有最高动态优先级的动作. 否则,如果可选择的动作并未被优先级排序, 但对两个规则使用`%merge'声明了相同的合并函数, Bison评价并解决它们之后调用合并函数求得结果. 否则它会报告一个歧义.

对GLR分析树使用这样一种数据结构是可能的, 这种结构可以以线性的时间(相对输入的大小)处理任意的LALR(1)文法, 在最坏情况下以二次方的时间处理任何非歧义文法(不一定是LALR(1)), 在最坏情况下以三次方的时间处理任何普通(可能是歧义的)上下文无关文法. 然而Bison当前使用一种更简单的数据结构, 这中数据结构需要与输入长度乘以输入的任意前需要缀最大栈数目成比例的时间. 因此,实际上,歧义或者不确定文法可能需要指数的时间和空间来处理. 然而,这种非常糟糕例子通常情况下很难见到. 文法中的不确定性通常是局部的--分析器一次只对很少一些记号"产生疑惑". 因此,当前的数据结构在大多数情况下足够用了. 特别地,对于文法的LALR(1)部分,它(注:通用GLR分析器) 仅仅比默认的Biosn分析器稍慢.

5.9 栈溢出以及如何避免它-Stack Overflow, and How to Avoid It
如果太多的记号被移进而没有被归约, Bison分析器栈可能会溢出. 在这种情况发生时, 分析器函数yyparse返回非零值, 暂停执行并调用yyerror来报告错误.

由于Bison分析器拥有生长的栈, 达到上限通常是由于使用右递归而不是左递归而产生的. 参阅 递归规则-Recursive Rules.

靠定义宏YYMAXDEPTH,你可以控制栈溢出之前的最大深度. 我们应该用正数定义这个宏. 这个值是在溢出之前被移进(而没被归约)的记号的最大数目.

允许的栈空间不需要一次分配完毕. 如果你为YYMAXDEPTH指定了一个很大的数字, 分析器实际上在开始之分配了一个空间很小的栈, 随个阶段性的需求,分析器会扩大栈的容量. 增大空间的分配自动并且沉默地进行. 因此,你不需要为了不需要多少空间的普通输入节省空间 而将YYMAXDEPTH定义的很小.

然而,我们同样不要把YYMAXDEPTH定义的很大以至于 在计算栈容量时产生算术溢出. 并且我们也不要将YYMAXDEPTH定义的比YYINITDEPTH还小.

如果你没有定义YYMAXDEPTH,那么它的默认值是10000.

你可靠定义宏YYINITDEPTH为一个正值来控制栈初始分配的空间. 除非你使用C99或者其它允许变长数组的语言和编译器, 对于C语言LALR(1)分析器来说, 这个值必须为编译时常量. YYINITDEPTH的默认值为200.

不要让YYINITDEPTH过大以至于当计算栈空间时发生溢出. 同样地,不要让YYINITDEPTH大于YYMAXDEPTH.

由于C和C++语义上的区别, 利用C++编译器编译的用C语言编写的LALR(1)分析器不能生长. (注:指栈不能生长) 在这种情况下(作为C++来编译C分析器), 我们建议你增加YYINITDEPTH的大小. 在不久的将来, 我们会提供涉及到这个问题的C++输出.



5.8 通用LR (GLR)分析-Generalized LR (GLR) Parsing
Bison产生确定性(determinstic)的分析器. 这种分析器基于先前输入和额外的超前扫描记号的摘要, 唯一性地选择进行归约的时机和如何进行归约. 结果,通常,Bison处理一个上下文无关文法语言族的自己. 由于歧义文法含有可以使用多种可能的归约序列的字符串, 所以在这种情况下不能使用确定的分析器. 这种情况同样适用于需要多于一个超前扫描记号的语言, 因为分析器缺乏做出决定所需要的必要信息, 这时它必须被制作成一个移进-归约分析器. 最终,如同之前提到的(参阅神秘的冲突-Mystery Conflicts一章), 有这样一些语言,Bison关于如何总结输入的特殊选择目前看起来缺少必要的信息.

当你在你的语法文件中使用`%glr-parser'声明的时候, Bison产生一个使用不同算法的分析器,这种分析器被称为通用LR(或GLR)分析器. 一个Bison GLR分析器使用同样基本的算法做为一个普通的Bison分析器进行分析, 但当存在一个不能被优先级规则(参阅优先级-Precedence一章)解决的移进/归约冲突, 或者一个归约/归约冲突时却有着与普通Bison分析器不同的行为. 当一个GLR分析器遭遇这种情况的时候, 它高效地分裂(splits)成多个分析器, 每个对应一种可能的移进或者归约. 这些分析器如常地进行分析,使用锁步(lock-step)消耗记号. 一些栈遭遇了其它的冲突并且进一步分裂, 一个Bison GLR分析栈是一个取代状态序列的高效的分析树.

实际上,每个栈代表一个关于正确分析的猜想. 剩余的输入可能会表明一个猜想是错误的, 在这种情况下,不正确的栈静静地消失. 另外,每个栈中的语义动作被保存而不是立即执行. 但一个栈消失时,它存储的的语义动作永远不会被执行. 当一个归约使两个栈等价的时候, 它们的语义动作集和导致归约的状态都会被保存. 我们说两个栈是等价的 当它们都代表相同的状态序列, 并且每对相应的状态代表一个产生相同输入流片段的语法符号.

每当分析器从有多个分析状态转换为一个分析状态时, 在执行了原来保存的动作后, 这个分析器将转变到通常的LALR(1)分析算法. 在这个转换过程中,一些栈上的状态含有可能的动作集(实际上是多个集)的语义值. 分析器试图从这些动作中挑选一个被`%prec'声明指定的有最高动态优先级的动作. 否则,如果可选择的动作并未被优先级排序, 但对两个规则使用`%merge'声明了相同的合并函数, Bison评价并解决它们之后调用合并函数求得结果. 否则它会报告一个歧义.

对GLR分析树使用这样一种数据结构是可能的, 这种结构可以以线性的时间(相对输入的大小)处理任意的LALR(1)文法, 在最坏情况下以二次方的时间处理任何非歧义文法(不一定是LALR(1)), 在最坏情况下以三次方的时间处理任何普通(可能是歧义的)上下文无关文法. 然而Bison当前使用一种更简单的数据结构, 这中数据结构需要与输入长度乘以输入的任意前需要缀最大栈数目成比例的时间. 因此,实际上,歧义或者不确定文法可能需要指数的时间和空间来处理. 然而,这种非常糟糕例子通常情况下很难见到. 文法中的不确定性通常是局部的--分析器一次只对很少一些记号"产生疑惑". 因此,当前的数据结构在大多数情况下足够用了. 特别地,对于文法的LALR(1)部分,它(注:通用GLR分析器) 仅仅比默认的Biosn分析器稍慢.

5.9 栈溢出以及如何避免它-Stack Overflow, and How to Avoid It
如果太多的记号被移进而没有被归约, Bison分析器栈可能会溢出. 在这种情况发生时, 分析器函数yyparse返回非零值, 暂停执行并调用yyerror来报告错误.

由于Bison分析器拥有生长的栈, 达到上限通常是由于使用右递归而不是左递归而产生的. 参阅 递归规则-Recursive Rules.

靠定义宏YYMAXDEPTH,你可以控制栈溢出之前的最大深度. 我们应该用正数定义这个宏. 这个值是在溢出之前被移进(而没被归约)的记号的最大数目.

允许的栈空间不需要一次分配完毕. 如果你为YYMAXDEPTH指定了一个很大的数字, 分析器实际上在开始之分配了一个空间很小的栈, 随个阶段性的需求,分析器会扩大栈的容量. 增大空间的分配自动并且沉默地进行. 因此,你不需要为了不需要多少空间的普通输入节省空间 而将YYMAXDEPTH定义的很小.

然而,我们同样不要把YYMAXDEPTH定义的很大以至于 在计算栈容量时产生算术溢出. 并且我们也不要将YYMAXDEPTH定义的比YYINITDEPTH还小.

如果你没有定义YYMAXDEPTH,那么它的默认值是10000.

你可靠定义宏YYINITDEPTH为一个正值来控制栈初始分配的空间. 除非你使用C99或者其它允许变长数组的语言和编译器, 对于C语言LALR(1)分析器来说, 这个值必须为编译时常量. YYINITDEPTH的默认值为200.

不要让YYINITDEPTH过大以至于当计算栈空间时发生溢出. 同样地,不要让YYINITDEPTH大于YYMAXDEPTH.

由于C和C++语义上的区别, 利用C++编译器编译的用C语言编写的LALR(1)分析器不能生长. (注:指栈不能生长) 在这种情况下(作为C++来编译C分析器), 我们建议你增加YYINITDEPTH的大小. 在不久的将来, 我们会提供涉及到这个问题的C++输出.



5.8 通用LR (GLR)分析-Generalized LR (GLR) Parsing
Bison产生确定性(determinstic)的分析器. 这种分析器基于先前输入和额外的超前扫描记号的摘要, 唯一性地选择进行归约的时机和如何进行归约. 结果,通常,Bison处理一个上下文无关文法语言族的自己. 由于歧义文法含有可以使用多种可能的归约序列的字符串, 所以在这种情况下不能使用确定的分析器. 这种情况同样适用于需要多于一个超前扫描记号的语言, 因为分析器缺乏做出决定所需要的必要信息, 这时它必须被制作成一个移进-归约分析器. 最终,如同之前提到的(参阅神秘的冲突-Mystery Conflicts一章), 有这样一些语言,Bison关于如何总结输入的特殊选择目前看起来缺少必要的信息.

当你在你的语法文件中使用`%glr-parser'声明的时候, Bison产生一个使用不同算法的分析器,这种分析器被称为通用LR(或GLR)分析器. 一个Bison GLR分析器使用同样基本的算法做为一个普通的Bison分析器进行分析, 但当存在一个不能被优先级规则(参阅优先级-Precedence一章)解决的移进/归约冲突, 或者一个归约/归约冲突时却有着与普通Bison分析器不同的行为. 当一个GLR分析器遭遇这种情况的时候, 它高效地分裂(splits)成多个分析器, 每个对应一种可能的移进或者归约. 这些分析器如常地进行分析,使用锁步(lock-step)消耗记号. 一些栈遭遇了其它的冲突并且进一步分裂, 一个Bison GLR分析栈是一个取代状态序列的高效的分析树.

实际上,每个栈代表一个关于正确分析的猜想. 剩余的输入可能会表明一个猜想是错误的, 在这种情况下,不正确的栈静静地消失. 另外,每个栈中的语义动作被保存而不是立即执行. 但一个栈消失时,它存储的的语义动作永远不会被执行. 当一个归约使两个栈等价的时候, 它们的语义动作集和导致归约的状态都会被保存. 我们说两个栈是等价的 当它们都代表相同的状态序列, 并且每对相应的状态代表一个产生相同输入流片段的语法符号.

每当分析器从有多个分析状态转换为一个分析状态时, 在执行了原来保存的动作后, 这个分析器将转变到通常的LALR(1)分析算法. 在这个转换过程中,一些栈上的状态含有可能的动作集(实际上是多个集)的语义值. 分析器试图从这些动作中挑选一个被`%prec'声明指定的有最高动态优先级的动作. 否则,如果可选择的动作并未被优先级排序, 但对两个规则使用`%merge'声明了相同的合并函数, Bison评价并解决它们之后调用合并函数求得结果. 否则它会报告一个歧义.

对GLR分析树使用这样一种数据结构是可能的, 这种结构可以以线性的时间(相对输入的大小)处理任意的LALR(1)文法, 在最坏情况下以二次方的时间处理任何非歧义文法(不一定是LALR(1)), 在最坏情况下以三次方的时间处理任何普通(可能是歧义的)上下文无关文法. 然而Bison当前使用一种更简单的数据结构, 这中数据结构需要与输入长度乘以输入的任意前需要缀最大栈数目成比例的时间. 因此,实际上,歧义或者不确定文法可能需要指数的时间和空间来处理. 然而,这种非常糟糕例子通常情况下很难见到. 文法中的不确定性通常是局部的--分析器一次只对很少一些记号"产生疑惑". 因此,当前的数据结构在大多数情况下足够用了. 特别地,对于文法的LALR(1)部分,它(注:通用GLR分析器) 仅仅比默认的Biosn分析器稍慢.

5.9 栈溢出以及如何避免它-Stack Overflow, and How to Avoid It
如果太多的记号被移进而没有被归约, Bison分析器栈可能会溢出. 在这种情况发生时, 分析器函数yyparse返回非零值, 暂停执行并调用yyerror来报告错误.

由于Bison分析器拥有生长的栈, 达到上限通常是由于使用右递归而不是左递归而产生的. 参阅 递归规则-Recursive Rules.

靠定义宏YYMAXDEPTH,你可以控制栈溢出之前的最大深度. 我们应该用正数定义这个宏. 这个值是在溢出之前被移进(而没被归约)的记号的最大数目.

允许的栈空间不需要一次分配完毕. 如果你为YYMAXDEPTH指定了一个很大的数字, 分析器实际上在开始之分配了一个空间很小的栈, 随个阶段性的需求,分析器会扩大栈的容量. 增大空间的分配自动并且沉默地进行. 因此,你不需要为了不需要多少空间的普通输入节省空间 而将YYMAXDEPTH定义的很小.

然而,我们同样不要把YYMAXDEPTH定义的很大以至于 在计算栈容量时产生算术溢出. 并且我们也不要将YYMAXDEPTH定义的比YYINITDEPTH还小.

如果你没有定义YYMAXDEPTH,那么它的默认值是10000.

你可靠定义宏YYINITDEPTH为一个正值来控制栈初始分配的空间. 除非你使用C99或者其它允许变长数组的语言和编译器, 对于C语言LALR(1)分析器来说, 这个值必须为编译时常量. YYINITDEPTH的默认值为200.

不要让YYINITDEPTH过大以至于当计算栈空间时发生溢出. 同样地,不要让YYINITDEPTH大于YYMAXDEPTH.

由于C和C++语义上的区别, 利用C++编译器编译的用C语言编写的LALR(1)分析器不能生长. (注:指栈不能生长) 在这种情况下(作为C++来编译C分析器), 我们建议你增加YYINITDEPTH的大小. 在不久的将来, 我们会提供涉及到这个问题的C++输出.



5.8 通用LR (GLR)分析-Generalized LR (GLR) Parsing
Bison产生确定性(determinstic)的分析器. 这种分析器基于先前输入和额外的超前扫描记号的摘要, 唯一性地选择进行归约的时机和如何进行归约. 结果,通常,Bison处理一个上下文无关文法语言族的自己. 由于歧义文法含有可以使用多种可能的归约序列的字符串, 所以在这种情况下不能使用确定的分析器. 这种情况同样适用于需要多于一个超前扫描记号的语言, 因为分析器缺乏做出决定所需要的必要信息, 这时它必须被制作成一个移进-归约分析器. 最终,如同之前提到的(参阅神秘的冲突-Mystery Conflicts一章), 有这样一些语言,Bison关于如何总结输入的特殊选择目前看起来缺少必要的信息.

当你在你的语法文件中使用`%glr-parser'声明的时候, Bison产生一个使用不同算法的分析器,这种分析器被称为通用LR(或GLR)分析器. 一个Bison GLR分析器使用同样基本的算法做为一个普通的Bison分析器进行分析, 但当存在一个不能被优先级规则(参阅优先级-Precedence一章)解决的移进/归约冲突, 或者一个归约/归约冲突时却有着与普通Bison分析器不同的行为. 当一个GLR分析器遭遇这种情况的时候, 它高效地分裂(splits)成多个分析器, 每个对应一种可能的移进或者归约. 这些分析器如常地进行分析,使用锁步(lock-step)消耗记号. 一些栈遭遇了其它的冲突并且进一步分裂, 一个Bison GLR分析栈是一个取代状态序列的高效的分析树.

实际上,每个栈代表一个关于正确分析的猜想. 剩余的输入可能会表明一个猜想是错误的, 在这种情况下,不正确的栈静静地消失. 另外,每个栈中的语义动作被保存而不是立即执行. 但一个栈消失时,它存储的的语义动作永远不会被执行. 当一个归约使两个栈等价的时候, 它们的语义动作集和导致归约的状态都会被保存. 我们说两个栈是等价的 当它们都代表相同的状态序列, 并且每对相应的状态代表一个产生相同输入流片段的语法符号.

每当分析器从有多个分析状态转换为一个分析状态时, 在执行了原来保存的动作后, 这个分析器将转变到通常的LALR(1)分析算法. 在这个转换过程中,一些栈上的状态含有可能的动作集(实际上是多个集)的语义值. 分析器试图从这些动作中挑选一个被`%prec'声明指定的有最高动态优先级的动作. 否则,如果可选择的动作并未被优先级排序, 但对两个规则使用`%merge'声明了相同的合并函数, Bison评价并解决它们之后调用合并函数求得结果. 否则它会报告一个歧义.

对GLR分析树使用这样一种数据结构是可能的, 这种结构可以以线性的时间(相对输入的大小)处理任意的LALR(1)文法, 在最坏情况下以二次方的时间处理任何非歧义文法(不一定是LALR(1)), 在最坏情况下以三次方的时间处理任何普通(可能是歧义的)上下文无关文法. 然而Bison当前使用一种更简单的数据结构, 这中数据结构需要与输入长度乘以输入的任意前需要缀最大栈数目成比例的时间. 因此,实际上,歧义或者不确定文法可能需要指数的时间和空间来处理. 然而,这种非常糟糕例子通常情况下很难见到. 文法中的不确定性通常是局部的--分析器一次只对很少一些记号"产生疑惑". 因此,当前的数据结构在大多数情况下足够用了. 特别地,对于文法的LALR(1)部分,它(注:通用GLR分析器) 仅仅比默认的Biosn分析器稍慢.

5.9 栈溢出以及如何避免它-Stack Overflow, and How to Avoid It
如果太多的记号被移进而没有被归约, Bison分析器栈可能会溢出. 在这种情况发生时, 分析器函数yyparse返回非零值, 暂停执行并调用yyerror来报告错误.

由于Bison分析器拥有生长的栈, 达到上限通常是由于使用右递归而不是左递归而产生的. 参阅 递归规则-Recursive Rules.

靠定义宏YYMAXDEPTH,你可以控制栈溢出之前的最大深度. 我们应该用正数定义这个宏. 这个值是在溢出之前被移进(而没被归约)的记号的最大数目.

允许的栈空间不需要一次分配完毕. 如果你为YYMAXDEPTH指定了一个很大的数字, 分析器实际上在开始之分配了一个空间很小的栈, 随个阶段性的需求,分析器会扩大栈的容量. 增大空间的分配自动并且沉默地进行. 因此,你不需要为了不需要多少空间的普通输入节省空间 而将YYMAXDEPTH定义的很小.

然而,我们同样不要把YYMAXDEPTH定义的很大以至于 在计算栈容量时产生算术溢出. 并且我们也不要将YYMAXDEPTH定义的比YYINITDEPTH还小.

如果你没有定义YYMAXDEPTH,那么它的默认值是10000.

你可靠定义宏YYINITDEPTH为一个正值来控制栈初始分配的空间. 除非你使用C99或者其它允许变长数组的语言和编译器, 对于C语言LALR(1)分析器来说, 这个值必须为编译时常量. YYINITDEPTH的默认值为200.

不要让YYINITDEPTH过大以至于当计算栈空间时发生溢出. 同样地,不要让YYINITDEPTH大于YYMAXDEPTH.

由于C和C++语义上的区别, 利用C++编译器编译的用C语言编写的LALR(1)分析器不能生长. (注:指栈不能生长) 在这种情况下(作为C++来编译C分析器), 我们建议你增加YYINITDEPTH的大小. 在不久的将来, 我们会提供涉及到这个问题的C++输出.



5.8 通用LR (GLR)分析-Generalized LR (GLR) Parsing
Bison产生确定性(determinstic)的分析器. 这种分析器基于先前输入和额外的超前扫描记号的摘要, 唯一性地选择进行归约的时机和如何进行归约. 结果,通常,Bison处理一个上下文无关文法语言族的自己. 由于歧义文法含有可以使用多种可能的归约序列的字符串, 所以在这种情况下不能使用确定的分析器. 这种情况同样适用于需要多于一个超前扫描记号的语言, 因为分析器缺乏做出决定所需要的必要信息, 这时它必须被制作成一个移进-归约分析器. 最终,如同之前提到的(参阅神秘的冲突-Mystery Conflicts一章), 有这样一些语言,Bison关于如何总结输入的特殊选择目前看起来缺少必要的信息.

当你在你的语法文件中使用`%glr-parser'声明的时候, Bison产生一个使用不同算法的分析器,这种分析器被称为通用LR(或GLR)分析器. 一个Bison GLR分析器使用同样基本的算法做为一个普通的Bison分析器进行分析, 但当存在一个不能被优先级规则(参阅优先级-Precedence一章)解决的移进/归约冲突, 或者一个归约/归约冲突时却有着与普通Bison分析器不同的行为. 当一个GLR分析器遭遇这种情况的时候, 它高效地分裂(splits)成多个分析器, 每个对应一种可能的移进或者归约. 这些分析器如常地进行分析,使用锁步(lock-step)消耗记号. 一些栈遭遇了其它的冲突并且进一步分裂, 一个Bison GLR分析栈是一个取代状态序列的高效的分析树.

实际上,每个栈代表一个关于正确分析的猜想. 剩余的输入可能会表明一个猜想是错误的, 在这种情况下,不正确的栈静静地消失. 另外,每个栈中的语义动作被保存而不是立即执行. 但一个栈消失时,它存储的的语义动作永远不会被执行. 当一个归约使两个栈等价的时候, 它们的语义动作集和导致归约的状态都会被保存. 我们说两个栈是等价的 当它们都代表相同的状态序列, 并且每对相应的状态代表一个产生相同输入流片段的语法符号.

每当分析器从有多个分析状态转换为一个分析状态时, 在执行了原来保存的动作后, 这个分析器将转变到通常的LALR(1)分析算法. 在这个转换过程中,一些栈上的状态含有可能的动作集(实际上是多个集)的语义值. 分析器试图从这些动作中挑选一个被`%prec'声明指定的有最高动态优先级的动作. 否则,如果可选择的动作并未被优先级排序, 但对两个规则使用`%merge'声明了相同的合并函数, Bison评价并解决它们之后调用合并函数求得结果. 否则它会报告一个歧义.

对GLR分析树使用这样一种数据结构是可能的, 这种结构可以以线性的时间(相对输入的大小)处理任意的LALR(1)文法, 在最坏情况下以二次方的时间处理任何非歧义文法(不一定是LALR(1)), 在最坏情况下以三次方的时间处理任何普通(可能是歧义的)上下文无关文法. 然而Bison当前使用一种更简单的数据结构, 这中数据结构需要与输入长度乘以输入的任意前需要缀最大栈数目成比例的时间. 因此,实际上,歧义或者不确定文法可能需要指数的时间和空间来处理. 然而,这种非常糟糕例子通常情况下很难见到. 文法中的不确定性通常是局部的--分析器一次只对很少一些记号"产生疑惑". 因此,当前的数据结构在大多数情况下足够用了. 特别地,对于文法的LALR(1)部分,它(注:通用GLR分析器) 仅仅比默认的Biosn分析器稍慢.

5.9 栈溢出以及如何避免它-Stack Overflow, and How to Avoid It
如果太多的记号被移进而没有被归约, Bison分析器栈可能会溢出. 在这种情况发生时, 分析器函数yyparse返回非零值, 暂停执行并调用yyerror来报告错误.

由于Bison分析器拥有生长的栈, 达到上限通常是由于使用右递归而不是左递归而产生的. 参阅 递归规则-Recursive Rules.

靠定义宏YYMAXDEPTH,你可以控制栈溢出之前的最大深度. 我们应该用正数定义这个宏. 这个值是在溢出之前被移进(而没被归约)的记号的最大数目.

允许的栈空间不需要一次分配完毕. 如果你为YYMAXDEPTH指定了一个很大的数字, 分析器实际上在开始之分配了一个空间很小的栈, 随个阶段性的需求,分析器会扩大栈的容量. 增大空间的分配自动并且沉默地进行. 因此,你不需要为了不需要多少空间的普通输入节省空间 而将YYMAXDEPTH定义的很小.

然而,我们同样不要把YYMAXDEPTH定义的很大以至于 在计算栈容量时产生算术溢出. 并且我们也不要将YYMAXDEPTH定义的比YYINITDEPTH还小.

如果你没有定义YYMAXDEPTH,那么它的默认值是10000.

你可靠定义宏YYINITDEPTH为一个正值来控制栈初始分配的空间. 除非你使用C99或者其它允许变长数组的语言和编译器, 对于C语言LALR(1)分析器来说, 这个值必须为编译时常量. YYINITDEPTH的默认值为200.

不要让YYINITDEPTH过大以至于当计算栈空间时发生溢出. 同样地,不要让YYINITDEPTH大于YYMAXDEPTH.

由于C和C++语义上的区别, 利用C++编译器编译的用C语言编写的LALR(1)分析器不能生长. (注:指栈不能生长) 在这种情况下(作为C++来编译C分析器), 我们建议你增加YYINITDEPTH的大小. 在不久的将来, 我们会提供涉及到这个问题的C++输出.



5.8 通用LR (GLR)分析-Generalized LR (GLR) Parsing
Bison产生确定性(determinstic)的分析器. 这种分析器基于先前输入和额外的超前扫描记号的摘要, 唯一性地选择进行归约的时机和如何进行归约. 结果,通常,Bison处理一个上下文无关文法语言族的自己. 由于歧义文法含有可以使用多种可能的归约序列的字符串, 所以在这种情况下不能使用确定的分析器. 这种情况同样适用于需要多于一个超前扫描记号的语言, 因为分析器缺乏做出决定所需要的必要信息, 这时它必须被制作成一个移进-归约分析器. 最终,如同之前提到的(参阅神秘的冲突-Mystery Conflicts一章), 有这样一些语言,Bison关于如何总结输入的特殊选择目前看起来缺少必要的信息.

当你在你的语法文件中使用`%glr-parser'声明的时候, Bison产生一个使用不同算法的分析器,这种分析器被称为通用LR(或GLR)分析器. 一个Bison GLR分析器使用同样基本的算法做为一个普通的Bison分析器进行分析, 但当存在一个不能被优先级规则(参阅优先级-Precedence一章)解决的移进/归约冲突, 或者一个归约/归约冲突时却有着与普通Bison分析器不同的行为. 当一个GLR分析器遭遇这种情况的时候, 它高效地分裂(splits)成多个分析器, 每个对应一种可能的移进或者归约. 这些分析器如常地进行分析,使用锁步(lock-step)消耗记号. 一些栈遭遇了其它的冲突并且进一步分裂, 一个Bison GLR分析栈是一个取代状态序列的高效的分析树.

实际上,每个栈代表一个关于正确分析的猜想. 剩余的输入可能会表明一个猜想是错误的, 在这种情况下,不正确的栈静静地消失. 另外,每个栈中的语义动作被保存而不是立即执行. 但一个栈消失时,它存储的的语义动作永远不会被执行. 当一个归约使两个栈等价的时候, 它们的语义动作集和导致归约的状态都会被保存. 我们说两个栈是等价的 当它们都代表相同的状态序列, 并且每对相应的状态代表一个产生相同输入流片段的语法符号.

每当分析器从有多个分析状态转换为一个分析状态时, 在执行了原来保存的动作后, 这个分析器将转变到通常的LALR(1)分析算法. 在这个转换过程中,一些栈上的状态含有可能的动作集(实际上是多个集)的语义值. 分析器试图从这些动作中挑选一个被`%prec'声明指定的有最高动态优先级的动作. 否则,如果可选择的动作并未被优先级排序, 但对两个规则使用`%merge'声明了相同的合并函数, Bison评价并解决它们之后调用合并函数求得结果. 否则它会报告一个歧义.

对GLR分析树使用这样一种数据结构是可能的, 这种结构可以以线性的时间(相对输入的大小)处理任意的LALR(1)文法, 在最坏情况下以二次方的时间处理任何非歧义文法(不一定是LALR(1)), 在最坏情况下以三次方的时间处理任何普通(可能是歧义的)上下文无关文法. 然而Bison当前使用一种更简单的数据结构, 这中数据结构需要与输入长度乘以输入的任意前需要缀最大栈数目成比例的时间. 因此,实际上,歧义或者不确定文法可能需要指数的时间和空间来处理. 然而,这种非常糟糕例子通常情况下很难见到. 文法中的不确定性通常是局部的--分析器一次只对很少一些记号"产生疑惑". 因此,当前的数据结构在大多数情况下足够用了. 特别地,对于文法的LALR(1)部分,它(注:通用GLR分析器) 仅仅比默认的Biosn分析器稍慢.

5.9 栈溢出以及如何避免它-Stack Overflow, and How to Avoid It
如果太多的记号被移进而没有被归约, Bison分析器栈可能会溢出. 在这种情况发生时, 分析器函数yyparse返回非零值, 暂停执行并调用yyerror来报告错误.

由于Bison分析器拥有生长的栈, 达到上限通常是由于使用右递归而不是左递归而产生的. 参阅 递归规则-Recursive Rules.

靠定义宏YYMAXDEPTH,你可以控制栈溢出之前的最大深度. 我们应该用正数定义这个宏. 这个值是在溢出之前被移进(而没被归约)的记号的最大数目.

允许的栈空间不需要一次分配完毕. 如果你为YYMAXDEPTH指定了一个很大的数字, 分析器实际上在开始之分配了一个空间很小的栈, 随个阶段性的需求,分析器会扩大栈的容量. 增大空间的分配自动并且沉默地进行. 因此,你不需要为了不需要多少空间的普通输入节省空间 而将YYMAXDEPTH定义的很小.

然而,我们同样不要把YYMAXDEPTH定义的很大以至于 在计算栈容量时产生算术溢出. 并且我们也不要将YYMAXDEPTH定义的比YYINITDEPTH还小.

如果你没有定义YYMAXDEPTH,那么它的默认值是10000.

你可靠定义宏YYINITDEPTH为一个正值来控制栈初始分配的空间. 除非你使用C99或者其它允许变长数组的语言和编译器, 对于C语言LALR(1)分析器来说, 这个值必须为编译时常量. YYINITDEPTH的默认值为200.

不要让YYINITDEPTH过大以至于当计算栈空间时发生溢出. 同样地,不要让YYINITDEPTH大于YYMAXDEPTH.

由于C和C++语义上的区别, 利用C++编译器编译的用C语言编写的LALR(1)分析器不能生长. (注:指栈不能生长) 在这种情况下(作为C++来编译C分析器), 我们建议你增加YYINITDEPTH的大小. 在不久的将来, 我们会提供涉及到这个问题的C++输出.



5.8 通用LR (GLR)分析-Generalized LR (GLR) Parsing
Bison产生确定性(determinstic)的分析器. 这种分析器基于先前输入和额外的超前扫描记号的摘要, 唯一性地选择进行归约的时机和如何进行归约. 结果,通常,Bison处理一个上下文无关文法语言族的自己. 由于歧义文法含有可以使用多种可能的归约序列的字符串, 所以在这种情况下不能使用确定的分析器. 这种情况同样适用于需要多于一个超前扫描记号的语言, 因为分析器缺乏做出决定所需要的必要信息, 这时它必须被制作成一个移进-归约分析器. 最终,如同之前提到的(参阅神秘的冲突-Mystery Conflicts一章), 有这样一些语言,Bison关于如何总结输入的特殊选择目前看起来缺少必要的信息.

当你在你的语法文件中使用`%glr-parser'声明的时候, Bison产生一个使用不同算法的分析器,这种分析器被称为通用LR(或GLR)分析器. 一个Bison GLR分析器使用同样基本的算法做为一个普通的Bison分析器进行分析, 但当存在一个不能被优先级规则(参阅优先级-Precedence一章)解决的移进/归约冲突, 或者一个归约/归约冲突时却有着与普通Bison分析器不同的行为. 当一个GLR分析器遭遇这种情况的时候, 它高效地分裂(splits)成多个分析器, 每个对应一种可能的移进或者归约. 这些分析器如常地进行分析,使用锁步(lock-step)消耗记号. 一些栈遭遇了其它的冲突并且进一步分裂, 一个Bison GLR分析栈是一个取代状态序列的高效的分析树.

实际上,每个栈代表一个关于正确分析的猜想. 剩余的输入可能会表明一个猜想是错误的, 在这种情况下,不正确的栈静静地消失. 另外,每个栈中的语义动作被保存而不是立即执行. 但一个栈消失时,它存储的的语义动作永远不会被执行. 当一个归约使两个栈等价的时候, 它们的语义动作集和导致归约的状态都会被保存. 我们说两个栈是等价的 当它们都代表相同的状态序列, 并且每对相应的状态代表一个产生相同输入流片段的语法符号.

每当分析器从有多个分析状态转换为一个分析状态时, 在执行了原来保存的动作后, 这个分析器将转变到通常的LALR(1)分析算法. 在这个转换过程中,一些栈上的状态含有可能的动作集(实际上是多个集)的语义值. 分析器试图从这些动作中挑选一个被`%prec'声明指定的有最高动态优先级的动作. 否则,如果可选择的动作并未被优先级排序, 但对两个规则使用`%merge'声明了相同的合并函数, Bison评价并解决它们之后调用合并函数求得结果. 否则它会报告一个歧义.

对GLR分析树使用这样一种数据结构是可能的, 这种结构可以以线性的时间(相对输入的大小)处理任意的LALR(1)文法, 在最坏情况下以二次方的时间处理任何非歧义文法(不一定是LALR(1)), 在最坏情况下以三次方的时间处理任何普通(可能是歧义的)上下文无关文法. 然而Bison当前使用一种更简单的数据结构, 这中数据结构需要与输入长度乘以输入的任意前需要缀最大栈数目成比例的时间. 因此,实际上,歧义或者不确定文法可能需要指数的时间和空间来处理. 然而,这种非常糟糕例子通常情况下很难见到. 文法中的不确定性通常是局部的--分析器一次只对很少一些记号"产生疑惑". 因此,当前的数据结构在大多数情况下足够用了. 特别地,对于文法的LALR(1)部分,它(注:通用GLR分析器) 仅仅比默认的Biosn分析器稍慢.

5.9 栈溢出以及如何避免它-Stack Overflow, and How to Avoid It
如果太多的记号被移进而没有被归约, Bison分析器栈可能会溢出. 在这种情况发生时, 分析器函数yyparse返回非零值, 暂停执行并调用yyerror来报告错误.

由于Bison分析器拥有生长的栈, 达到上限通常是由于使用右递归而不是左递归而产生的. 参阅 递归规则-Recursive Rules.

靠定义宏YYMAXDEPTH,你可以控制栈溢出之前的最大深度. 我们应该用正数定义这个宏. 这个值是在溢出之前被移进(而没被归约)的记号的最大数目.

允许的栈空间不需要一次分配完毕. 如果你为YYMAXDEPTH指定了一个很大的数字, 分析器实际上在开始之分配了一个空间很小的栈, 随个阶段性的需求,分析器会扩大栈的容量. 增大空间的分配自动并且沉默地进行. 因此,你不需要为了不需要多少空间的普通输入节省空间 而将YYMAXDEPTH定义的很小.

然而,我们同样不要把YYMAXDEPTH定义的很大以至于 在计算栈容量时产生算术溢出. 并且我们也不要将YYMAXDEPTH定义的比YYINITDEPTH还小.

如果你没有定义YYMAXDEPTH,那么它的默认值是10000.

你可靠定义宏YYINITDEPTH为一个正值来控制栈初始分配的空间. 除非你使用C99或者其它允许变长数组的语言和编译器, 对于C语言LALR(1)分析器来说, 这个值必须为编译时常量. YYINITDEPTH的默认值为200.

不要让YYINITDEPTH过大以至于当计算栈空间时发生溢出. 同样地,不要让YYINITDEPTH大于YYMAXDEPTH.

由于C和C++语义上的区别, 利用C++编译器编译的用C语言编写的LALR(1)分析器不能生长. (注:指栈不能生长) 在这种情况下(作为C++来编译C分析器), 我们建议你增加YYINITDEPTH的大小. 在不久的将来, 我们会提供涉及到这个问题的C++输出.


r Recovery
我们通常不能接受让一个程序在遇到语法错误时就终止. 例如,一个编译器应该充分的从错误中恢复 以便分析输入文件的其余部分并且检查其中的错误; 一个计算器应该接受其它的表达式.

在每个输入都是一行的简单互交命令分析器中, 让yyparse在遇到错误时返回1并且 使调用者忽略剩下的输入行(然后重新调用yyparse就足够了. 但是这对于编译器来说显然不够, 因为为它忘记了导致错误的全部构造上下文. 在编译器输入中,深入到一个函数内部的语法错误, 并不应该使编译器对待后面的行像对待源文件的开始一样.

				你可以靠编写一个识别特殊记号error的规则来定义如何从语法错误中恢复. 它总是一个已经被定义(你不需要声明它)并且保留做错误处理使用的终结符. 每当一个语法错误发生时,Bison分析器就产生一个error记号; 如果你在当前的上下文中提供了一个识别该记号的规则, 那么分析可以继续进行.

				例如:

				 	
				stmnts:  /* empty string */ /* 空字符串 */
				        | stmnts '/n'
						        | stmnts exp '/n'
								        | stmnts error '/n'
										这个例子的第四个规则说明了一个错误后紧跟一个换行 对任何stmnts是有效的添加.

										如果错误发生在exp中间的话会发生什么情况? 这个错误恢复规则,被精确地解释为应用于一个stmnts,一个error 和一个换行的精确序列. 如果一个错误发生在一个exp中间, 那么在栈中最后的stmnts之后很可能有一些额外的记号或者自表达式, 即有一些记号在下一个换行之前被读入. 所以这个规则并不按通常的方法应用.

										但是Bison可以靠丢弃部分语义上下文和部分输入来强制地使这个规则(注:错误恢复规则)适用于这种情况. 首先,它从栈中丢弃状态和对象直到回到一个可以接受error的状态. (这意味着分析过的子表达式被丢弃,并且回到最后一个完整的stmnts.) 这时error记号可以被移进. 之后,如果旧的超前扫描记号不能接受移进下一个记号, 分析器如读记号并且丢弃它们直到找到一个可以接受的记号. 在这个例子中,Bison读入并丢弃输入直到下一个换行符以便应用第四个规则. 注意到丢弃的符号通常是内存泄露之源,参阅释放丢弃的符号-Freeing Discarded Symbols以获取更多信息.

										在语法中,对于错误恢复规则的选择就是对错误恢复策略的选择. 一个简单而使用的策略是如果检测到一个错误,跳过当前输入行的剩余部分:

										 	
										stmnt: error ';'  /* On error, skip until ';' is read.  */ /* 当错误出现时,跳过剩余部分直到读入 ';' */
为一个已经分析的作括号恢复匹配一个右括号也是非常实用的. 否则,右括号很可能不匹配地出现并且引发另外的更严重的错误消息:

 	
primary:  '(' expr ')'
        | '(' error ')'
		        …
				        ;
						错误恢复策略是必要的猜测. 当它们猜测的时候,一个语法错误通常会导致另外一个错误. 在上面的例子中, 错误规则猜测:一个错误是由于一个stmnt中的错误输入引起的. 假设一个伪造的分号被插入到一个有效的stmt中间. 在错误恢复规则从第一错误恢复之后,分析器会立刻发现另外一个错误, 因为在伪造的分号之后的文字也是一个无效的stmt.

						为了阻止错误的倾泄而出, 分析器在第一个错误之后立即发现另一个错误时,不会输出错误消息; 仅在三个连续的数据记号被成功归约之后,分析器才会恢复输出错误消息.

						注意到接受error记号的规则像其它任何规则一样也可以有动作.

						你可以通过使用宏yyerrok使错误消息立即恢复. 如果你在错误恢复规则的动作中使用它, 没有任何错误消息会被抑制. 这个宏不需要任何参数; `yyerrok;'是一个有效的C语句.

						先前的超前扫描记号在一个错误后会被立即再分析. 如果这是不可接受的, 那么宏yyclearin可以用于清除这个记号. 将语句`yyclearin;'写入错误恢恢复规则的动作中.

						例如,假设在遭遇一个语法错误时, 一个错误处理程序被调用用于将输入流前进到重新开始分析的地方. 词法分析器返回的下一个记号很可能是正确的. 前一个超前扫描记号应该用`yyclearin;'丢弃.

						宏YYRECOVERING代表一个表达式. 这个表达式在分析器从语法错误中恢复时值为1,在其它的时候值为0. 值为1指明了要抑制新的语法错误产生的错误消息.


7. 处理上下文依赖-Handling Context Dependencies
Bison的分析模式是首先分析记号,之后将它们组合成更大的句法单元. 在许多语言中,一个记号的意义受到上下文的影响. 尽管这破坏了Bison范例, 某些技术(被称为kludges)可以使你有能力为这种语言编写Bison分析器.
7. 处理上下文依赖-Handling Context Dependencies
Bison的分析模式是首先分析记号,之后将它们组合成更大的句法单元. 在许多语言中,一个记号的意义受到上下文的影响. 尽管这破坏了Bison范例, 某些技术(被称为kludges)可以使你有能力为这种语言编写Bison分析器.
7. 处理上下文依赖-Handling Context Dependencies
Bison的分析模式是首先分析记号,之后将它们组合成更大的句法单元. 在许多语言中,一个记号的意义受到上下文的影响. 尽管这破坏了Bison范例, 某些技术(被称为kludges)可以使你有能力为这种语言编写Bison分析器.
7. 处理上下文依赖-Handling Context Dependencies
Bison的分析模式是首先分析记号,之后将它们组合成更大的句法单元. 在许多语言中,一个记号的意义受到上下文的影响. 尽管这破坏了Bison范例, 某些技术(被称为kludges)可以使你有能力为这种语言编写Bison分析器.
7. 处理上下文依赖-Handling Context Dependencies
Bison的分析模式是首先分析记号,之后将它们组合成更大的句法单元. 在许多语言中,一个记号的意义受到上下文的影响. 尽管这破坏了Bison范例, 某些技术(被称为kludges)可以使你有能力为这种语言编写Bison分析器.
7. 处理上下文依赖-Handling Context Dependencies
Bison的分析模式是首先分析记号,之后将它们组合成更大的句法单元. 在许多语言中,一个记号的意义受到上下文的影响. 尽管这破坏了Bison范例, 某些技术(被称为kludges)可以使你有能力为这种语言编写Bison分析器.
7. 处理上下文依赖-Handling Context Dependencies
Bison的分析模式是首先分析记号,之后将它们组合成更大的句法单元. 在许多语言中,一个记号的意义受到上下文的影响. 尽管这破坏了Bison范例, 某些技术(被称为kludges)可以使你有能力为这种语言编写Bison分析器.
7. 处理上下文依赖-Handling Context Dependencies
emantic Info in Token Types
C语言就有上下文依赖: 标识符使用的方法依赖于当当前的意义. 例如,考虑这个:

 	
foo (x);
这看起来是一个函数调用语句,但如果foo是一个typedef名称, 那么这实际上是一个x的声明. C语言的Bison分析器如何决定怎么分析这个输入呢?

GNU C使用的办法是让它们有不同的记号类型, INDENTIFIER和TYPENAME. 当yylex发现一个标识符, 它搜索当前的标识符声明以便决定返回什么样的记号类型: 如果标识符由一个typedef声明的,就返回TYPENAME,否则返回IDENTIFIER.

这时,语法规则就可以通过对要识别的记号类型的选择来表达上下文依赖. IDENTIFIER可以作为一个表达式被接受,但是TYPENAME却不能. TYPENAME可以开始一个声明,但是IDENTIFIER却不可以. 在标识符的意义不明显的上下文中, 例如在可以隐藏一个typedef名称的声明中, TYPENAME和IDENTIFIER都是可接受的-- 并没有一个针对没一种记号类型的规则.

如果在接近分析标识符的地方决定允许什么种类的标识符, 那么这个技术可以简单的应用. 但是在C语言中却不总是这样: C允许重新声明之前声明的带有明确类型的typedef名称.

 	
typedef int foo, bar, lose;
static foo (bar);        /* redeclare bar as static variable */ /* 重新声明bar为一个静态变量 */
static int foo (lose);   /* redeclare foo as function */ /* 重新声明foo为一个函数 */

不幸的是,这个名称被一个复杂的句法结构--"声明符"所分隔.

结果,C语言的Bison分析器的某些部分要被复制,并且要改变所有非终结符的名称: 一次是为了分析可以被重定义的typedef声明, 一次是为了分析不能被重定义的声明. 这里是复制的部分. 为了简洁省略了动作.

 	
initdcl:
          declarator maybeasm '='
		            init
					        | declarator maybeasm
							        ;

notype_initdcl:
          notype_declarator maybeasm '='
		            init
					        | notype_declarator maybeasm
							        ;
									在这里initdcl可以重新声明一个typedef名称, 但是notype_initdcl却不能. declarator和notype_declarator的区别在于同一类型的不同种类.

									这种技术和词法关联技术(在下一节描述)有一些相似之处. 它们的区别是,这里的信息是全局的并且用于程序的其它目的. 一个真正的词法关联含有一个受上下文控制的特殊目的标志.

									7.2 词法关联-Lexical Tie-ins
									另外一种处理上下文依赖的方法是词法关联(lexical tie-in): 一个由Bison动作设置的标志, 它的目的是改变分析记号的方式.

																							例如,假设我们有一种类似C的语言, 但是它带有一个特殊的`hex (hex-expr)'结构. 在关键字hex之后是一个括号之中全部为十六进制整数的表达式. 特别地,在那个上下文中,记号`a1b'必须被看做是一个整数而不是一个标识符. 这里就是你如何处理它:

																							 	
																							%{
																									int hexflag;
																									int yylex (void);
																									void yyerror (char const *);
																									%}
																									%%
																									…
																									expr:   IDENTIFIER
																									| constant
																									| HEX '('
{ hexflag = 1; }
expr ')'
{ hexflag = 0;
		$$ = $4; }
		| expr '+' expr
{ $$ = make_sum ($1, $3); }
…
;

constant:
INTEGER
| STRING
;

						  这里我们假设yylex观察hexflag的值; 当它的值非零时,所有的整数被分析成十六进制数, 并且带有字母的标识符也尽可能的被翻译成整数.

						  hexflag出现在分析器文件的Prologue部分以便动作可以访问它 (参阅Prologue部分-The Prologue一章). 你还必须在yylex中编写代码来获得这个标志.

7.3 词法关联和错误恢复-Lexical Tie-ins and Error Recovery
词法关联对你使用的任何错误恢复规则都有严格的要求. 参阅 错误恢复-Error Recovery.

这样的原因是错误恢复规则的目的是放弃对一个结构的分析并且恢复到某个更大的结构中去. 不例如,在类似C的语言中, 一个典型的错误恢复规则是跳过记号直到下一个分号, 并且开始分析一个新的语句, 像这样:

 	
stmt:   expr ';'
        | IF '(' expr ')' stmt { … }
		        …
				        error ';'
						                { hexflag = 0; }
										        ;
如果在`hex (expr)'之中存在一个语法错误, 这个错误恢复规则就会被应用, 完整的`hex (expr)'的动作永远都不会执行. 所以对于其余的输入或者直到下一个关键字hex, hexflag仍然被置1.这会导致标识符被错误地解释为整数.

为了避免这个错误,错误恢复规则自己要将hexflag清零.

也有可能存在一个与表达式一起工作的错误恢复规则. 例如,可能有一个应用于括号匹配的规则, 并且它跳跃到右括号:

 	
expr:   …
        | '(' expr ')'
		                { $$ = $2; }
						        | '(' error ')'
								        …
										如果这个规则在hex结构中执行, 它不会放弃那个结构(由于它作于在结构内部的括号(注:结构指hex结构)). 因此,它不应该将标志清零: hex结构的其余部分应该在该标志仍然有效的情况下被分析.

										如果有一个错误规则依靠当时的状况可能放弃hex结构也可能不放弃的话, 我们该怎么办? 没有办法编写一个可以决定是否放弃hex结构的动作. 所以,如果你使用了词法关联, 最好保证你的错误恢复规则不是这种类型. 你必须要确定每个规则总是要清零或总不要清零.

										8. 调式你的分析器-Debugging Your Parser
										开发分析器可能是一种挑战,特别当你不理解它的算法的时候 (参阅Bison分析器算法-The Bison Parser Algorithm一章). 即使是这样,有些时候一个关于自动的详细描述可能会有所帮助 (参阅理解你的分析器- Understanding Your Parser一章), 或者跟踪分析器的执行可以给你关于为它什么做出不正确的行为一些灵感. (参阅跟踪你的分析器- Tracing Your Parser一章).

8.1 理解你的分析器-Understanding Your Parser
如同本文档其它部分描述的 (参阅Bison分析器算法-The Bison Parser Algorithm一章), Bison分析器是移进/归约自动机(shift/reduce automata). 在一些情况下(比你希望的要更频繁), 调整或者简单的修正一个分析器需要考虑这个自动机. Bions提供了它(自动机)的两种表示方法,文本的或者图形的(作为一个VCG文件).

当指定选项`--report'或者`--verbose'时Bison生成文本文件, 参阅 调用Bison-Invoking Bison. 它的名称由移除分析器输出文件名`.tab.c'或者`.c'而添加`.output'取代. 因此,如果输入文件是`foo.y', 那么默认的分析器文件为`foo.tab.c'. 结果,冗长(verbose)输出文件为`foo.output'.

下面的语法文件`calc.y'将在稍后使用:

 	
%token NUM STR
%left '+' '-'
%left '*'
%%
exp: exp '+' exp
   | exp '-' exp
      | exp '*' exp
	     | exp '/' exp
		    | NUM
			   ;
useless: STR;
%%
bison 报告:

 	
calc.y: warning: 1 useless nonterminal and 1 useless rule
calc.y:11.1-7: warning: useless nonterminal: useless
calc.y:11.10-12: warning: useless rule: useless: STR
calc.y: conflicts: 7 shift/reduce
当指定`--report=state', 除了文件`calc.tab.c', 它还创建了包含如下详细信息的文件`calc.outut'. 输出和精确表述的顺序可能有所不同, 但是对此的解释是相同的.

第一个部分包括了由前面的与/或结合性解决的冲突的详细信息.

 	
Conflict in state 8 between rule 2 and token '+' resolved as reduce.
Conflict in state 8 between rule 2 and token '-' resolved as reduce.
Conflict in state 8 between rule 2 and token '*' resolved as shift.
…
下一个部分列出了仍然有冲突的状态清单.

 	
State 8 conflicts: 1 shift/reduce
State 9 conflicts: 1 shift/reduce
State 10 conflicts: 1 shift/reduce
State 11 conflicts: 4 shift/reduce
下一个部分报告了没有用处的记号,非终结符和规则. 没用处的非终结符和规则被移除以便产生一个更小的分析器, 但是没用记号被保留,因为它们可能被扫描器使用, (应该注意到"没用处的"和"没被使用的"之间的区别).

 	
Useless nonterminals:
   useless

   Terminals which are not used:
      STR

	  Useless rules:
#6     useless: STR;
	  下一个部分重新制造了Bison使用的精确语法:

	   	
	  Grammar

	    Number, Line, Rule
		    0   5 $accept -> exp $end
			    1   5 exp -> exp '+' exp
				    2   6 exp -> exp '-' exp
					    3   7 exp -> exp '*' exp
						    4   8 exp -> exp '/' exp
							    5   9 exp -> NUM

								并且报告了使用的符号:

								 	
								Terminals, with rules where they appear

								$end (0) 0
								'*' (42) 3
								'+' (43) 1
								'-' (45) 2
								'/' (47) 4
								error (256)
		NUM (258) 5

		Nonterminals, with rules where they appear

		$accept (8)
		    on left: 0
			exp (9)
		    on left: 1 2 3 4 5, on right: 0 1 2 3 4
			Bison之后进入到自己的自动机, 并且用项目(items)集,也被成为指明规则(pointed rules),来描述每个状态. 每个都是一个产生式规则,并且带有表示输入光标的点号.

			 	
			state 0

			    $accept  ->  . exp $   (rule 0)

		    NUM         shift, and go to state 1

			    exp         go to state 2

				这些有如下含义: "状态0相应地处于分析的开始, 在初始规则中,处于开始符号(这里是exp)的右端. 当分析器归约了一个产生的exp的规则并返回这个状态之后, 控制流跳转到状态2. 如果没有这样的非终结符转化并且超前扫描记号是NUM, 那么这个记号被移进到分析器栈中,控制流跳转到状态1. 任何其它的超前扫描记号都会引发一个语法错误."

				即使状态0中的唯一活动规则看起来是规则0, 报告将NUM列举为一个超前扫描记号, 这是因为NUM可以在任何转向exp的规则的开头. 默认地,Bison报告项目集的核心(core or kernel of the item set). 但是如果你想查看更详细的信息,你可以使用选项`--report=itemset'调用bison 来列出所有的项目,包括那些可以由此派生的.

				 	
				state 0

				    $accept  ->  . exp $   (rule 0)
		    exp  ->  . exp '+' exp   (rule 1)
			    exp  ->  . exp '-' exp   (rule 2)
				    exp  ->  . exp '*' exp   (rule 3)
					    exp  ->  . exp '/' exp   (rule 4)
						    exp  ->  . NUM   (rule 5)

		    NUM         shift, and go to state 1

			    exp         go to state 2
				在状态1中...

				 	
				state 1

				    exp  ->  NUM .   (rule 5)

		    $default    reduce using rule 5 (exp)
		规则5,`exp: NUM;'是完整的. 无论超前扫描记号(`$default')是什么,分析器都会归约它. 如果是从状态0跳转过来,在归约之后会回到到状态0,并且之后会跳转到状态2(`exp: go to state 2').

		 	
		state 2

		    $accept  ->  exp . $   (rule 0)
		    exp  ->  exp . '+' exp   (rule 1)
			    exp  ->  exp . '-' exp   (rule 2)
				    exp  ->  exp . '*' exp   (rule 3)
					    exp  ->  exp . '/' exp   (rule 4)

						    $           shift, and go to state 3
							    '+'         shift, and go to state 4
								    '-'         shift, and go to state 5
									    '*'         shift, and go to state 6
										    '/'         shift, and go to state 7

											在状态2中,自动机只能进行归约符号. 例如,根据项目`exp -> exp . '+' exp',如果超前扫描记号为`+', 它会被移进到分析器栈中,并且状态机控制会跳转到状态4, 对应项目`exp -> exp '+' . exp'. 由于没有默认动作,任何非上述列出的记号会引起一个语法错误.

											状态3被称为终态(finial state))或者接受态(accepting state):

													 	
													state 3

													    $accept  ->  exp $ .   (rule 0)

		    $default    accept
			初始规则已经完成(已经读取开始符号和输入终结), 分析成功退出.

			状态4到7解释的很直接,留给读者自己分析:

			 	
			state 4

			    exp  ->  exp '+' . exp   (rule 1)

				    NUM         shift, and go to state 1

					    exp         go to state 8

						state 5

						    exp  ->  exp '-' . exp   (rule 2)

							    NUM         shift, and go to state 1

								    exp         go to state 9

									state 6

									    exp  ->  exp '*' . exp   (rule 3)

										    NUM         shift, and go to state 1

											    exp         go to state 10

												state 7

												    exp  ->  exp '/' . exp   (rule 4)

													    NUM         shift, and go to state 1

														    exp         go to state 11

															正如报告开始部分声明的,`State 8 conflicts:1 shift/reduce':

															 	
															state 8

															    exp  ->  exp . '+' exp   (rule 1)
																    exp  ->  exp '+' exp .   (rule 1)
																	    exp  ->  exp . '-' exp   (rule 2)
																		    exp  ->  exp . '*' exp   (rule 3)
																			    exp  ->  exp . '/' exp   (rule 4)

																				    '*'         shift, and go to state 6
																					    '/'         shift, and go to state 7

																						    '/'         [reduce using rule 1 (exp)]
																							    $default    reduce using rule 1 (exp)
		的确,有两个与超前扫描记号`/'关联的动作: 或者移进(并且转到状态7),或者归约规则1. 这个冲突意味着或者语法是歧义的或者分析器缺少做出正确决定的信息. 这个语法确实是歧义的,因为我们并未指明`/'的优先级, 句子`NUM + NUM / NUM'可以被分析为对应于移进`/'的`NUM + (NUM / NUM)', 也可以被分析为对应于归约规则1的`(NUM + NUM) / NUM'.

		由于在LALR(1)分析中只能做出一个动作, Bison武断地选择不使用归约,参阅移进/归约冲突-Shift/Reduce Conflicts. 被丢弃的动作被报告于方括号中.

		注意到先前的所有状态只有一个单一可能的动作: 或者移进下一个记号并且转到相应的状态, 或者归约一个规则. 在其它的情况下, 例如, 当移进和归约都是可能的或者多个归约都是可能的, 这是需要超前扫描记号来选择动作. 状态8就是这样一种状态:如果超前扫描记号是`*'或者`/' 那么多做是移进,否则动作是归约动作1. 换句话说,前两项,对应于规则1,当超前扫描记号是`*'的时候是不符合条件的, 因为我们指明了`*'有比`+'更高的优先级. 更普通地说, 一些项目仅在某些可能的超前扫描记号下是符合条件的. 当使用选项`--report=look-ahead',Bison会指明这些超前扫描记号:

		 	
		state 8

		exp  ->  exp . '+' exp  [$, '+', '-', '/']   (rule 1)
		exp  ->  exp '+' exp .  [$, '+', '-', '/']   (rule 1)
		exp  ->  exp . '-' exp   (rule 2)
		exp  ->  exp . '*' exp   (rule 3)
		exp  ->  exp . '/' exp   (rule 4)

		'*'         shift, and go to state 6
		'/'         shift, and go to state 7

		'/'         [reduce using rule 1 (exp)]
$default    reduce using rule 1 (exp)
		其余的状态与之类似:


		state 9

		exp  ->  exp . '+' exp   (rule 1)
		exp  ->  exp . '-' exp   (rule 2)
		exp  ->  exp '-' exp .   (rule 2)
		exp  ->  exp . '*' exp   (rule 3)
		exp  ->  exp . '/' exp   (rule 4)

		'*'         shift, and go to state 6
		'/'         shift, and go to state 7

		'/'         [reduce using rule 2 (exp)]
$default    reduce using rule 2 (exp)

		state 10

		exp  ->  exp . '+' exp   (rule 1)
		exp  ->  exp . '-' exp   (rule 2)
		exp  ->  exp . '*' exp   (rule 3)
		exp  ->  exp '*' exp .   (rule 3)
		exp  ->  exp . '/' exp   (rule 4)

		'/'         shift, and go to state 7

		'/'         [reduce using rule 3 (exp)]
$default    reduce using rule 3 (exp)

		state 11

		exp  ->  exp . '+' exp   (rule 1)
		exp  ->  exp . '-' exp   (rule 2)
		exp  ->  exp . '*' exp   (rule 3)
		exp  ->  exp . '/' exp   (rule 4)
		exp  ->  exp '/' exp .   (rule 4)

		'+'         shift, and go to state 4
		'-'         shift, and go to state 5
		'*'         shift, and go to state 6
		'/'         shift, and go to state 7

		'+'         [reduce using rule 4 (exp)]
		'-'         [reduce using rule 4 (exp)]
		'*'         [reduce using rule 4 (exp)]
		'/'         [reduce using rule 4 (exp)]
$default    reduce using rule 4 (exp)

		注意到状态11包含冲突不仅仅因为缺少`/'相对于`+',`-'和`*'的优先级, 还由于并未指定`/'的结合性.

		8.2 跟踪你的分析器-Tracing Your Parser
		如果Bison语法编译正确但是在运行的时候并未达到你想要的目的, yydeug分析器追踪特性可以帮你指明原因.

		有多种方法激活追踪机制的编译:

		宏 YYDEBUG
		当你编译分析器的时候,将宏YYDEBUG定义成非零指. 这种方式与POSIX Yacc兼容. 你可以使用`-DYYDEBUG=1'作为一个编译器选项或者你可以将`define YYDEBUG 1' 放入语法文件的Prologue部分.(参阅Prologue部分- The Prologue一章).

		选项 `-t', `--debug'
		当你运行Bison(参阅调用Bison-Invoking Bison一章)时, 使用`-t'选项. 这也与POSIX兼容.

		指令 `%debug'
		加入%debug指令(参阅Bison声明总结-Bison Declaration Summary一章). 这是一个Bison扩展,当Bison为不使用预处理器的语言输出分析器的时候很实用. 除非你要考虑POSIX可移植性问题, 否则这是一个很好的解决方案.

		我们建议你应该总是激活调式选项以便随时进行调试.

		追踪机制使用YYFPRINTF (stderr, format, args)形式的宏调用输出信息. 在这里format和args是普通的printf的格式和参数. 如果你定义YYDEBUG为一个非零值但是没有定义YYFPRINTF, <stdio.h>自动被加入并且YYPRINTF被定义为fprintf.

		一旦你使用了追踪机制编译程序, 请求一个追踪的方法是在变量yydebug中存储一个非零值. 你可以考编写C代码(也许在main中)做到这一点, 你也可以使用C调试器来改变这个值.

		当yydebug为非零的时候,分析器执行的每一步都产生一个写入stderr一两行的追踪信息. 追踪信息告诉你这些东西:

		每次调用yylex时,读取记号的种类.
		每次移进记号的时候,分析器栈的深度和完整的内容. (参阅分析器状态-Parser States一章)
		每次归约一个规则时,这个规则是哪个规则,和在归约之后状态栈的完整内容.
		弄清这些信息的意思有助于查阅由Bison选项`-v'产生的列表文件(listing file). (参阅调用Bison-Invoking Bison一章). 这个文件按照各种规则的位置展示了每个状态的意义, 还展示了每个状态会怎样处理每个输入记号. 当你阅读连续的追踪信息时, 你可以看到分析器按照它在列表文件中的指示工作. 最终你会到达发生不期望事情的地方, 并且你会发现语法的哪一个部分存在问题.

		分析器文件是一个C程序,你可以使用C调式器调试它, 但是我们很难解释它在做些什么. 分析器函数是一个有限状态机解释器, 除了动作以外它反复执行相同的代码. 只有变量的值才能表示它正在语法的那个地方工作.

		调试信息通常给出了每个读入记号的符号类型而不是它的语义值. 你可以定一个名为YYPRINT的宏来打印这个值. 如果你定义YYPRINT, 它应带有三个参数. 分析器将传递标准I/O流,记号类型的数字码和记号指(从yylval中).

		这里有一个适用于多功能计算器的YYPRINT (参阅mfcalc的声明部分-Declarations for mfcalc一章):

				 	
				%{
						static void print_token_value (FILE *, int, YYSTYPE);
#define YYPRINT(file, type, value) print_token_value (file, type, value)
						%}

						… %% … %% …

		static void
print_token_value (FILE *file, int type, YYSTYPE value)
{
		if (type == VAR)
				fprintf (file, "%s", value.tptr->name);
		else if (type == NUM)
				fprintf (file, "%d", value.val);
}

9. 调用Bison-Invoking Bison
调用Bison的通常方法如下:

 	
bison infile
这里的file是通常以`.y'结尾的语法文件名. 分析器文件名由`.tab.c'代替`.y'取得. 因此,`bison foo.y'产生`foo.tab.c', `bison hack/foo.y'产生`hack/foo.tab.c'. 如果你在你语法文件中使用C++代码而不是C, 把它命名为`foo.ypp'或者`foo.y++'. 那么,输出文件的扩展名类型给定的输入 (分别为`foo.tab.cpp'和`foo.tab.c++'.

				例如:

				 	
				bison -d infile.yxx

				将会产生`infile.tab.cxx'和`infile.tab.hxx',并且

				 	
				bison -d -o output.c++ infile.y
				会产生`output.c++'和`outfile.h++'.

				为了与POSIX兼容, 标准的Bison发行版也包含一个名为yacc的脚本, 该脚本使用`-y'选项调用Bison.


9.1 Bison选项-Bison Options
Bison既支持传统的单字母选项也支持可记忆长选项名称. 用`--'取代`-'来指明常长项名称. Bison允许选项名称缩写只要它们是唯一的. 当长选项带有一个参如,如`--file-prefix', 用`='连接选项名称和参数.

这里有一个Bison可以是用的选项清单, 按照短选项字母顺序排列. 在它之后是一个常选项的交叉键.

操作模式:

`-h'
`--help'
打印一个Bison命令行选项的总结并退出.

`-V'
`--version'
打印Bison的版本号并退出.

`-y'
`--yacc'
与`-o y.tab.c'等价; 分析器输出文件名为`y.tab.c', 并且其它输出称为`y.output'和`y.tab.h'. 这个选项的目的是模拟Yacc的输出文件命名惯例. 因此,如下的shell脚本可以替代Yacc, 并且Bison发行版包含一个这种为POSIX兼容的脚本.

 	
#! /bin/sh
bison -y "$@"
调整分析器:

`-S file'
`--skeleton=file'
指明要使用的骨架(skeleton). 除非你正在开发Bison否你很可能不需要这个选项.

`-t'
`--debug'
在分析器文件中,定义宏YYDEBUG为1,如果还没有定义它, 以便调试机制被编译. 参阅 追踪你的分析器-Tracing Your Parser.

`--locations'
%locations的伪装.参阅 声明总结-Decl Summary.

`-p prefix'
`--name-prefix=prefix'
%name-prefix="prefix"的伪装. 参阅 声明总结-Decl Summary.

`-l'
`--no-lines'
在分析器文件中不放入任何的#line预处理器命令. Bison通常将它们放入分析器文件以便C编译起和调试器将错误关联到你的源文件, 语法文件. 这个选项会关联错误到分析器文件,将它视为一个独立的源文件.

`-n'
`--no-parser'
%no-parser的伪装. 参阅 声明总结-Decl Summary.

`-k'
`--token-table'
%token-table的伪装. 参阅 声明总结-Decl Summary.

调整输出:

`-d'
`--defines'
伪装%defines,例如,向一个额外的文件写入语法中记号类型名称的宏定义和一些其它的声明. 参阅 声明总结-Decl Summary.

`--defines=defines-file'
与上述相同,但是保存到文件defines-file.

`-b file-prefix'
`--file-prefix=prefix'
%verbose的伪装,例如,指明所有Bison输出文件的前缀. 参阅 声明总结-Decl Summary.

`-r things'
`--report=things'
向一个额外的输出文件写入如下things的详细描述清,并由逗号分隔:

state
语法,冲突(解决的和未解决的)以及LALR自动机.

look-ahead
包含state并且增加每个规则的超前扫描记号集自动机的描述.

itemset
包含state并且增加每个状态的全部项目集的自动机而不仅仅是它核心的自动机.

例如,在下面的语法中

`-v'
`--verbose'
%verbose的伪装,例如,向额外的输出文件写入语法和分析器的详细描述. 参阅 声明总结-Decl Summary.

`-o filename'
`--output=filename'
为分析器文件指明filename.

其它输出文件的名称像`-v'和`-d'选项的描述一样由filename构成.

`-g'
输出一个由Bison计算的LALR(1)语法自动机的VCG定义. 如果语法文件是`foo.y', VCG输出文件将会是`foo.vcg'.

`--graph=graph-file'
-graph的行为和`-g'的行为一样. 唯一的区别在于它含有一个指明输出图形文件的可选参数.

9.3 Yacc库-Yacc Library
Yacc库包含yyerror和main函数的默认实现. 通常情况下,这些默认实现没有什么用处,但是POSIX要求它们. 要使用Yacc库,使用选项`-ly'链接你的程序. 注意到Bison实现的Yacc库在GNU通用许可证下发行. (参阅GNU GENERAL PUBLIC LICENSE一章).

如果你使用Yacc库的yyerror函数, 你应该如下地声明yyerror:

 	
int yyerror (char const *);
Bison忽略yyerror返回的int值. 如果你使用Yacc库的main函数, 你的yyparse函数应该有如下原型:

 	
int yyparse (void);



10. 常见问题-Frequently Asked Questions
许多关于Bison的问题会偶尔出现. 这里提到一些.

10.1 分析器栈溢出-Parser Stack Overflow
 	
我的分析器返回带有`parser stack overflow'的消息.
我能做些什么?

这个问题已经在其它地方讨论过了参阅 Recursive Rules.

10.2 我如何复位分析器-How Can I Reset the Parser
下面的现象有许多征兆,导致了下面典型的问题:

 	
我调用了yyparse多次,
		当输入正确时,它正确地工作;
但是当发现一个分析错误的时,所有其它的调用也失败了.
我如何才能重置yyparse的错误标志?

或者:

 	
我的分析器包含了一个对`#include'类似特性的支持.
当我从yyparse调用yyparse时,即使我指明我需要一个%pure-parser,
		它仍然会失败.
		这些典型的问题并不产生于Bison自己而是产生于Lex生成的扫描器. 出于速度的目的,这些扫描器使用容量很大的缓冲区, 它们可能不会注意到输入文件的变化. 作为一个例子,考虑下面的源文件,

		`first-line.l':

		%{
#include <stdio.h>
#include <stdlib.h>
				%}
				%%
				.*/n    ECHO; return 1;
				%%
				int
				yyparse (char const *file)
{
		  yyin = fopen (file, "r");
		    if (!yyin)
					    exit (2);
			  /* One token only.  */ /* 只有一个记号 */
			  yylex ();
			    if (fclose (yyin) != 0)
						    exit (3);
				  return 0;
}

int
main (void)
{
		  yyparse ("input");
		    yyparse ("input");
			  return 0;
}
如果文件`input'包含

input:1: Hello,
		input:2: World!
		那么你并未两次取得第一行,而是:

		 	
		$ flex -ofirst-line.c first-line.l
		$ gcc  -ofirst-line   first-line.c -ll
		$ ./first-line
		input:1: Hello,
		input:2: World!
		因此,无论什么时候改变yyin, 你必须告诉Lex声称的扫描器丢弃当前的缓冲转换到新的缓冲中. 这依赖于你的Lex的实现;可以参阅它的文档获取更多信息. 对于Flex,在每一个yyin的改变后调用`YY_FLUSH_BUFFER'可以做到这一点. 如果你的Flex生成扫描器需要读取多个输入流来处理类似文件包含的特性, 你可以考虑使用FLex函数如`yy_switch_to_buffer'来操纵多个输入缓冲.

		如果你的FLex声称扫描器使用了开始条件(参阅The Flex Manual中`Start conditions'一章(flex)Start conditions), 你还可能复位扫描器状态,例如, 使用一个BEGIN (0)调用,退回到开始条件.

		10.5 实现跳转/循环-Implementing Gotos/Loops
		 	
		我的简单计算器支持变量,赋值和函数,
		但是我如何才能实现跳转或循环?
		虽然这个文档中包含的例子很有教学性, 但它模糊了分析器(它的工作是恢复文字的结构并将它转化为程序模块) 和处理这些结构的过程(如执行)之间的区别. 这在被称为直接线性程序中工作良好. 例如直接执行模式:一个接一个的执行简单指令.

		如果你需要的更丰富的模式, 你可能需要分析器生一种表示它(注:分析器)已经恢复的结构的树; 这种树被通常成为抽象语法树(abstract syntax tree)或者简写为AST. 之后,用多种方法遍历这棵树会激活对它的执行或翻译, 这最终会导致产生一个解释起或者编译器.

. Bison符号-Bison Symbols
变量: @$
在动作中,规则左手端的位置 参阅 位置概述-Locations Overview.

变量: @n
在动作中,规则右端第n个符号的位置. 参阅 位置概述-Locations Overview.

变量: $$
在动作中,规则左端的语义值. 参阅 动作-Actions.

变量: $n
在动作中,规则右端第n个符号的语义值. 参阅 动作-Actions.

分隔符: %%
用于分隔语法规则部分和Bison声明部分或者epilogue部分. 参阅 Bison语法文件的布局-The Overall Layout of a Bison Grammar.

分隔符: %{code%}
在`%{'和`%}'之间的代码不做任何解释被直接复制到输出文件. 这些代码组成了输入文件的Prologue部分. 参阅 Bison语法的提纲-Outline of a Bison Grammar.

结构: /*…*/
注释分隔符,类似C.

分隔符: :
分隔动作的结果和它的部件. 参阅 描述语法规则的语法-Syntax of Grammar Rules.

分隔符: ;
结束一个规则. 参阅 描述语法规则的语法-Syntax of Grammar Rules.

分隔符: |
分隔同一个非终结符结果的不同规则. 参阅 描述语法规则的语法-Syntax of Grammar Rules.

符号: $accept
预定义非终结符, 它的唯一规则为`$accept: start $end', 这里的start是开始符号. 参阅 开始符号- The Start-Symbol. 它不能在语法中使用.

指令: %debug
激活分析器调试. 参阅 声明总结-Decl Summary.

指令: %defines
为扫描器创建一个头文件的Bison声明. 参阅 声明总结-Decl Summary.

指令: %destructor
指明分析器如何回收被丢弃符号相关的内存. 参阅 释放丢弃的符号- Freeing Discarded Symbols.

指令: %dprec
在分析的时候赋予规则一个优先级来解决归约/归约冲突的Bison声明. 参阅 编写GLR分析器-Writing GLR Parsers.

符号: $end
用来标记流结束的预定义记号,不能在语法中使用.

符号: error
一个保留的用于错误恢复的记号名称. 这个记号可以用在语法规则中用来允许Bison分析器在不终止处理的前提下 识别一个错误. 实际上,一个包含错误的句子可被认为是有效的. 遇到一个语法错误时, 记号error成为了当前的超前扫描记号. 与error相应的动作被执行,并且超前扫描记号被重置为 最初引起错误的记号. 参阅 错误恢复-Error Recovery.

指令: %error-verbose
请求冗长模式的Bison声明, 指明了当调用yyerror时的错误消息字符串.

指令: %file-prefix="prefix"
设置输出文件前缀的Bison声明.参阅 声明总结-Decl Summary.

指令: %glr-parser
声称GLR分析器的Bison声明. 参阅 编写GLR分析器-Writing GLR Parsers.

指令: %initial-action
在分析器前运行代码.参阅 在分析前执行动作- Performing Actions before Parsing.

指令: %left
为操作符指定左结合性的Bison声明. 参阅 操作符优先级-Operator Precedence.

指令: %lex-param {argument-declaration}
指明yylex的额外参数的Bison声明. 参阅 纯分析器的调用惯例-Calling Conventions for Pure Parsers.

指令: %merge
赋予规则一个合并函数的Bison声明. 如果有一个归约/归约冲突的规则带有相同的合并函数, 那么这个函数被应用于两个语义值来获得单一的结果. 参阅 Writing GLR Parsers-编写GLR分析器.

指令: %name-prefix="prefix"
重命名外部符号的Bison声明.参阅 声明总结-Decl Summary.

指令: %no-lines
在分析器文件中避免产生#line指令的Bison声明. 参阅 声明总结-Decl Summary.

指令: %nonassoc
声明一个无结合性记号. 参阅 操作符优先级-Operator Precedence.

指令: %output="filename"
设置分析器文件的Bison声明 参阅 声明总结-Decl Summary.

指令: %parse-param {argument-declaration}
指定yyparse接受的额外参数的Bison声明. 参阅 分析器函数yyparse- The Parser Function yyparse.

指令: %prec
给特定的规则指定优先级的Bison声明. 参阅 上下文依赖优先级-Context-Dependent Precedence.

指令: %pure-parser
请求一个纯(可重入)分析器的Bison声明. 参阅 一个纯(可重入)分析器-A Pure (Reentrant) Parser.

指令: %right
指定记号右结合性的Bison声明. 参阅 操作符优先级-Operator Precedence.

指令: %start
指定开始符号的Bison声明参阅 开始符号-The Start-Symbol.

指令: %token
声明记号但不指定优先级. 参阅 记号类型名称-Token Type Names.

指令: %token-table
在分析器文件中加入符号名称表的Bison声明. 参阅 声明总结-Decl Summary.

指令: %type
声明非终结符的Bison声明. 参阅 非终结符-Nonterminal Symbols.

符号: $undefined
所有yylex返回的未定义值被映射到这个预定义符号. 它不能在语法中使用,[untranslated]rather,use error.

指令: %union
指定多种可能语义值数据类型的Bison声明. 参阅 值类型集-The Collection of Value Types.

宏: YYABORT
通过使yyparse立即返回1,来伪装发生一个未恢复的语法错误的宏. 并不调用错误报告函数yyerrpr. 参阅 分析器函数ppyarse-The Parser Function yyparse.

宏: YYACCEPT
通过使yyparse立即返回0,来伪装语言的一个完整的表达已经被读取的宏. 参阅 分析器函数ppyarse-The Parser Function yyparse.

宏: YYBACKUP
从分析器栈中丢弃一个值并伪造一个超前扫描记号的宏. 参阅 在动作中使用的特殊特征-Special Features for Use in Actions.

变量: yychar
包含当前超前扫描记号的正数值的外部整数变量. (在一个纯分析器中,它是一个在yyparse中的局部变量). 错误恢复规则可能要检查这个变量. 参阅 在动作中使用的特殊特征-Special Features for Use in Actions.

变量: yyclearin
在错误恢复规则中使用的宏.它清除先前的超前扫描记号. 参阅 错误恢复-Error Recovery.

宏: YYDEBUG
使分析器带有追踪代码的宏. 参阅 跟踪你的分析器-Tracing Your Parser.

变量: yydebug
默认被置0的外部整数变量. 如果yydebug被赋予一个非零值, 分析器会输入关于输入符号和分析器动作的信息. 参阅 跟踪你的分析器-Tracing Your Parser.

宏: yyerrok
使分析器在一个语法错误之后立即恢复到正常模式的宏. 参阅 错误恢复-Error Recovery.

宏: YYERROR
一个假装刚刚发现一个语法错误的宏: 调用yyerror然后执行通常的错误恢复如果可能的话(参阅错误恢复-Error Recovery一章) 或者(如果恢复是不可能的)使yyparse返回1. 参阅 错误恢复-Error Recovery.

函数: yyerror
用户提供的当发现错误时被yyparse调用的函数. 参阅 错误报告函数yyerror-The Error Reporting Function yyerror.

宏: YYERROR_VERBOSE
一个在Prologue部分用#define定义的陈旧的宏, 当调用yyerror时,它请求详细的错误消息字符串. 你把YYERROR_VERBOSE定义成什么东西并没有影响, 有影响的只是你是否定义了它. 使用%error-verbose是更好的选择.

宏: YYINITDEPTH
指定分析器栈初始大小的宏. 参阅 栈溢出-Stack Overflow.

函数: yylex
用户提供的词法分析器函数, 不带有任何参数来获得下一个记号. 参阅 词法分析器函数yylex-The Lexical Analyzer Function yylex.

宏: YYLEX_PARAM
一个用于指明yyparse传递到yylex的额外参数(或者额外参数列表)的陈旧的宏. 不赞成继续使用这个宏,它只被Yacc类似分析器支持. 参阅 纯分析器的调用惯例-Calling Conventions for Pure Parsers.

变量: yylloc
yylex应该将一个记号的行列号放入这个外部变量. (在纯分析器中,它是一个yyparse的局部变量, 它的地址被传递到yylex). 如果你在语法动作中不使用`@'特性,你可以忽略这个变量. 参阅 记号的文字位置-Textual Locations of Tokens.

Type: YYLTYPE
yyloc的数据类型;默认地为一个带有四个成员的结构体. 参阅 位置的数据类型-Data Types of Locations.

变量: yylval
yylex应该将记号相关的语义值放入这个变量. (在纯分析器中,它是一个yyparse中的局部变量,并且它的地址被传递到yylex.) 参阅 记号的语义值-Semantic Values of Tokens.

宏: YYMAXDEPTH
指明分析器栈最大容的宏. 参阅 栈溢出-Stack Overflow.

变量: yynerrs
一个全局变量,每次出现语法错误时自增1. (在纯分析器中,它是一个yyparse中的局部变量.) 参阅 错误报告函数yyerror-The Error Reporting Function yyerror.

函数: yyparse
Bison产生的分析器函数;调用这个函数开始分析. 参阅 分析器函数yyparse-The Parser Function yyparse.

宏: YYPARSE_PARAM
指明yyparse应该接受的参数名成的陈旧宏. 不赞成继续使用这个宏,它只被Yacc类似分析器支持. 参阅 纯分析器的调用惯例-Calling Conventions for Pure Parsers.

宏: YYRECOVERING
一个宏,它的值指明了分析器是否正在从错误中恢复. 参阅 动作中使用的特殊特征-Special Features for Use in Actions.

宏: YYSTACK_USE_ALLOCA
用于控制当C语言LALR(1)分析器需要扩展它的栈时,alloca的使用. 如果定义为0,分析器会使用malloc来扩展它的栈. 如果定义为1,分析器则会使用alloca. 除了0和1以外的值保留用于Bison以后的扩展. 如果没有被定义, YYSTACK_USA_ALLOCA默认为0.

如果你定义YYSTACK_USE_ALLOCA为1, 你有责任使alloca是可见的, 例如,使用GCC,或者包含<stdlib.h>. 此外,在更普通的情况下, 如果你的代码可能运行在一个有限栈容量和不可信任栈溢出检查的主机上的时候, 你应将YYMAXDEPTH设为当调用alloca时, 在一个在任何目标主机不会产生栈溢出的值. 你可以检查Bison生成的代码来决定适当的数值. 这需要在底层详细实现的专业技术.

类型: YYSTYPE
语义值的数据类型;默认为int. 参阅 语义值的数据类型-Data Types of Semantic Values.


B. 词汇表-Glossary
Backus-Naur Form (BNF; also called "Backus Normal Form")
Backus-Naur 范式 (BNF; 也被称为 "Backus正规范式")
由John Backus倡导的,最初用于描述上下文无关文法的正式方法. 在Peter Naur他的称为Algol60报告的1960-01-02委员会文档中得到少许改进. 参阅 语言与上下文无关文法-Languages and Context-Free Grammars.

Context-free grammars
上下文无关文法
描述可以使用而不考虑上下文的规则的文法. 因此,如果有一个规则说一个整数可做为一个表达式使用, 那么,整数在任何地方都是一个允许的表达式. 参阅 语言与上下文无关文法-Languages and Context-Free Grammars.

Dynamic allocation
动态分配
在执行期间分配内存,而不是在编译期间或者进入一个函数时.

Empty string
空字符串
模拟集合论中的空集, 空字符串是长度为0的字符串.

Finite-state stack machine
有限状态栈机
一种含有多种离散状态的机器,每个时刻只有一种状态. 当处理输入的时候,机器按照机器逻辑的指定从一个状态转换到另一个状态. 对于分析器来说,输入就是要分析的语言, 状态对应于语法规则中的各个阶段. 参阅 Bison分析器算法-The Bison Parser Algorithm.

Generalized LR (GLR)
		通用LR (GLR)
		一种可以处理包括那些不是LALR(1)的上下文无关文法的分析算法. 它用来解决Bison通常的LALR(1)算法不能解决的冲突. 它高效地分裂成多个分析器,尝试所有可能的分析,丢弃那些在额外上下文提示下失败的分析器. 参阅 通用LR分析-Generalized LR Parsing.

		Grouping
		分组
		一个(通常)在语法上可再分的语言结构; 例如C中的`expression'或者'declaration'. 参阅 语言和上下文无关文法-Languages and Context-Free Grammars.

		Infix operator
		中缀操作符
		放置在操作数中间指定某些操作的算术操作符.

		Input stream
		输入流
		在设备或程序间的连续数据流.

		Language construct
		语言结构
		一种语言的典型应用模式. 例如,一种C语言的结构是if语句. 参阅 语言和上下文无关文法-Languages and Context-Free Grammars.

		Left associativity
		左结合性
		拥有左结合性的操作符被从左至右地分析: `a+b+C'首先计算`a+b'然后和`c'一起计算. 参阅 操作符优先级-Operator Precedence.

		Left recursion
		左递归
		一个结果符号同样是第一个部件符号的规则; 例如: `expseq1 : expseq1 ',' exp;'. 参阅 递归规则-Recursive Rules.

		Left-to-right parsing
		自左至右分析
		同过自左至右分析一个个地分析记号来分析一个句子. 参阅 Bison 分析器算法-The Bison Parser Algorithm.

		Lexical analyzer (scanner)
		词法分析器 (扫描器)
		一个读取输入流并逐个返回记号的函数. 参阅 词法分析器函数yylex-The Lexical Analyzer Function yylex.

		Lexical tie-in
		词法关联
		一个由语法规则动作设置的标志用来改变分析记号的方法. 参阅 词法关联-Lexical tie-in.

		Literal string token
		字符串文字记号
		一个由两个或者更多字符组成的记号.参阅 符号-Symbols.

		Look-ahead token
		超前扫描记号
		一个已经读取但未移进的记号. 参阅 超前扫描记号-Look-Ahead Tokens.

		LALR(1)
		一种Bison(像大多数其它分析器一样)可以处理的上下文无关文法. LR(1)的子集. 参阅 令人迷惑的归约/归约冲突-Mysterious Reduce/Reduce Conflicts.

		LR(1)
		一种上下文无关文法, 它在大多数时侯需要一个超前扫描记号来消除任何输入片段的歧义.

		Nonterminal symbol
		非终结符
		一个代表可以通过规则表达为更小结构的语法结构; 换句话说,一个不是记号的结构. 参阅 符号-Symbols.

		Parser
		分析器
		一个靠分析从词法分析器传递过来的记号的语法结构来识别有效句子的函数.

		Postfix operator
		后缀操作符
		放置在操作数后执行某些操作的算术操作符.

		Reduction
		归约
		依照一个语法规则将非终结符和/或终结符的序列替换为非终结符. 参阅 Bison分析器算法-The Bison Parser Algorithm.

		Reentrant
		可重入
		一个可重入的子程序是一个可以被任意次地并行调用并且调用间相互不干扰的子程序. 参阅 一个纯(可重入)分析器-A Pure (Reentrant) Parser.

		Reverse polish notation
		逆波兰记号
		一种所有操作符都是后缀操作符的语言.

		Right recursion
		右递归
		一个结果记号也是它最后部件记号的规则; 例如 `expseq1: exp ',' expseq1;'. 参阅 递归规则-Recursive rules.

		Semantics-语义
		在计算机语言中,语义由每个语言实例的动作指明, 例如,每个语句的意义. 参阅 定义语言的语义-Defining Language Semantics.

		Shift-移进
		我们说一个分析器移进当它决定进从流中进一步分析输入而不是 立即归约一些已经识别的规则. 参阅 Bison分析器算法-The Bison Parser Algorithm.

		Single-character literal
		单字符文字
		一个被识别和解释为它自己的单一字符. 参阅 从正规文法转换到Bison输入-From Formal Rules to Bison Input.

		Start symbol
		开始符号
		代表要分析语言的一个完整有效的表述的非终结符. 在语言描述中,开始符号通常被列为第一个非终结符. 参阅 开始符号-The Start-Symbol.

		Symbol table
		符号表
		用来识别和使用已经存在的符号信息的数据结构. 在进行分析器符号表存储符号名称和相关数据. 参阅 多功能计算器-Multi-function Calc.

		Syntax error
		语法错误
		一个发生在分析无效语法的输入流时的错误. 参阅 错误恢复-Error Recovery.

		Token
		记号
		一个基本的不可再分的语言单元. 在语法中,描述一个记号的符号是终结符. Bison分析器的输入是来自词法分析器的记号流. 参阅 Symbols-符号.

		Terminal symbol
		终结符
		在语法中不包含含规则因此语法上不可再分的语法符号. 它表示的输入片段是一个记号. 参阅 语言与上下文无关文法-Languages and Context-Free Grammars.
