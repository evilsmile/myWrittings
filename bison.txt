一个Bison语法文件有四个主要的部分, 就像如下所示,由恰当的分隔符分隔.
%{
	Prologue
%}

	Bison declarations

%%
	Grammar rules

%%
	Epilogue

注释包含在`/* … */'之中,并且可以在任意部分出现. 做为一个GNU扩展,`//'引进了一个直到这行末尾的注释.

Prologue部分包括宏定义和在语法规则动作中使用的函数和变量的声明. 这些将复制到分析器文件的开头以便先于yyparse的定义. 你可以使用`#include'来从头文件获取声明. 如果你不需要任何的C声明,你可以省略这个部分的括号分隔符`%{'和`%}'.

3.1.1 Prologue部分-The prologue
Prologue部分包括宏定义和在语法规则动作中使用的函数和变量的声明. 这些将复制到分析器文件的开头以便先于yyparse的定义. 你可以使用`#include'来从头文件获取声明. 如果你不需要任何的C声明,你可以省略这个部分的括号分隔符`%{'和`%}'.

可以有多个与Bison declarations混合的Prologue部分. 这种做法允许你拥有相互引用的C和Bison声明. 例如,%union可以使用定义在头文件的数据类型, 并且你希望使用带有YYSTYPE类型做为参数的函数. 可以通过两个Prologue块来实现这个, 一个在%union之前,另一个在之后.

	
%{
	  #include <stdio.h>

	  #include "ptypes.h"
%}

	%union {
		  long int n;
		    tree t;  /* tree is defined in `ptypes.h'. */ 
			           /* tree 在`ptypes.h'中定义. */
	}

%{
	  static void print_token_value (FILE *, int, YYSTYPE);
	    #define YYPRINT(F, N, L) print_token_value (F, N, L)
%}


Bison declatations部分包含了定义终结符和非终结符的声明,优先级等等. 在一些简单的语法中,可以不需要任何声明. 

Grammar Rules部分包含了一个或多个Bison语法规则. 参阅 用来表示语法规则的语法-Syntax of Grammar Rules.
在这里至少应该有一个语法规则,并且第一个`%%'(先于语法规则的那个)绝对不能省略,解释它在文件的最开头.

就像Prologue部分被复制到开头一样,Epilogue部分被逐字地复制到分析器文件的结尾. 如果你想放一些代码却没必要放在yyparse的定义之前,这里是最方便的地方. 例如,yylex和yyerror的定义就经常放在这里. 因为C语言要求函数在使用之前必须声明. 你经常需要在Prologue部分声明类似yylex和yyerror的函数, 即使你在Epilogue部分已经定义了它们. 参阅 分析器C语言接口-Parser C-Language Interface.
如果最后一部分为空,你可以省略分隔它的分隔符`%%'.
Bison分析器自己包含了许多以`yy'和`YY'开头宏和标识符的定义. 所以在Epilogue部分避免使用这种类型的名字(出了这个文档讨论的之外)是一个好主意.

Bison语法中的符号(Symbols)代表着语言的语法类型.

一个终结符(terminal symbol)(也被称做符号类型(token type)代表了一类从构造上等价的记号. 你在语法中使用符号的意思就是一个这种类型的记号是允许的. Bison分析器将符号表示为数字码. yylex返回一个记号类型来指明一个被读入的记号是什么类型的. 你不需要了解那个码的数值是多少; 你使用代表它的符号就可以了.

一个非终结符(noterminal symbol)代表一类从构造上等价的组. 符号名称用于编写语法规则. 按照惯例,所有的非终结符都应该是小写的.
符号名称可以是字母,数字(不在开头),下划线和句点. 句点只在非终结符中有意义.

在语法中书写终结符有三种方法:

一个命名符号类型(named token type)用类似C语言的标识符书写. 按照惯例,它们应该是大写字母. 每一个这种名称必须由一个Bison声明%token定义. 参阅 符号类型的名称-Token Type Names.
一个字符记号类型(character token type(或者文字字符记号(literal character token) 用如同C语言字符常量相同的语法书写; 例如,'+'是一个字符记号类型. 除非你要指明字符记号类型的语义值类型(参阅语义值的数据类型-Data Types of Semantic Values一章), 结合性或优先级(参阅操作符优先级-Operator Precedence一章), 否则没有必要声明它们.
按照惯例,一个字符记号类型只用于表示一个由特定字符组成的记号. 因此,记号类型'+'用于将字符`+'表示为一个记号. 没有对此惯例的强制要求, 但是如果你不按照惯例做, 你的程序会使其它的读者感到困惑.
	所有常用的C语言的字符转义序列都可以在Bison中使用, 但是你不能使用一个空字符作为一个字符文字. 因为它的数字码是0,这表示输入结束.(参阅yylex的调用惯例-Calling Convention for yylex一章). 并且,不像标准C 三字符词(trigraphs)(注:由"??"开头的九种转义,为了在缺少标准C标点的宿主上使用标准C,可参考标准C文档) 在Bison中并没有特殊意义并且反斜杠换行也是不允许的.

	一个文字串记号(literal string token)用类似C语言中的字符串常量来书写; 例如,"<="是一个文字串记号. 除非你要指明文字串记号的语义值类型(参阅值类型-Value Type一章), 结合性或优先级(参阅优先级-Precedence一章),你没有必要声明它们.
		你可以使用%token(参阅符号声明-Token Declarations一章)将文字串记号关联一个符号名称作为别名. 如果你不这样做,词法分析器必须从yytname表中重新找到文字串记号的代码. (参阅调用惯例-Calling Convention一章).

	警告: 文字串记号在Yacc中不能工作.

	按照惯例,一个文字串记号只用于表示一个由特定串构成的记号. 因此,你用该使用类型"<="表示作为记号的字符串`<='. Bison并没有强制要求这种管理,但是如果你偏离了惯例, 阅读你程序的人会感到困惑.

				所有常用的C语言的字符转义序列都可以在Bison中使用, 但是你不能使用一个空字符作为一个字符文字. 因为它的数字码是0,这表示输入结束. (参阅 yylex的调用惯例-Calling Convention for yylex.) 并且,不像标准C, 三字符词(trigraphs)(注:由"??"开头的九种转义,为了在缺少标准C标点的宿主上使用标准C,可参考标准C文档) 在Bison中并没有特殊意义并且反斜杠换行也是不允许的. 一个文字串记号必须包括两个或更多个字符; 对于进包含一个字符的记号,你应该使用字符记号(参考以上).

				怎样选择终结符的写法对于它的语法意义没有影响. 它只依赖于它出现在规则的什么地方以及什么时候分器起函数返回那个符号.

				yylex的返回值通常是终结符,除非返回一个代表结束输入的0或者负值. 无论你采用那种方法在语法规则中书写符号类型, 你应该在yylex的定义中采用相同的写法. 单字符符号类型的数字码简单地就是那个字符的正数编码, 所以,即使当char是有符号时你需要将它转换成unsigned char来避免主机上符号扩展 yylex仍可以使用相同的值来产生必要的代码. 每一个命名记号类型在分析器文件中变为一个C宏, 所以yylex可以使用名称代表那个编码. (这就是为什么句点在终结符中不起作用.) 参阅 yylex的调用惯例-Calling Convention for yylex.

				如果yylex是在另外的文件中定义的, 你需要安排符号类型的宏定义在那里是可见的. 在你运行Bison的时候使用`-d'选项 以便让它将这些宏定义写入一个另外的头文件`name.tab.h'. 你可以将它加入其它需要它的文件. 参阅 调用Bison-Invoking Bison.

				如果你要编写一个可以移植到任何标准C宿主上的语法, 你必须只能从基本标准C字符集中选择使用非零字符记号类型. 这个字符集由10个数字,52个大小写英文字母,和在下列C语言字符串中的字符构成的:


		"/a/b/t/n/v/f/r !/"#%&'()*+,-./:;<=>?[//]^_{|}~"
		yylex函数和Bison必须为字符记号使用一个一致的字符集和编码. 例如,如果你在ASCII环境中运行Bison, 但是在不兼容的例如EBCDIC的环境中编译和运行最终的程序, 最终程序可能不会工作.因为Bison产生的表格将字符记号假定为ASCII数字值. 发布带有Bison在ASCII环境中产生的C源文件的软件是标准的做法, 所以在与ASCII不兼容的平台的安装器必须在编译它们之前重新构建这些文件.

		符号error是一个保留用作错误恢复的终结符(参阅错误恢复-Error Recovery一章); 你不应该为了其它的目的而使用它. 特别地,yylex永远不应该返回这个值(注:error). 除非你明确地在声明中赋予一个你的记号值为256,否则error记号的默认值是256.



3.3 描述语法规则的语法-Syntax of Grammar Rules
一个Bison语法规则通常有如下的下形式:

	
result: components…
        ;
		reault所在是这个规则描述的非终结符而components 是被这个规则组合在一起的多种终结符和非终结符.(参阅符号-Symbols一章)

	例如:

		
	exp:      exp '+' exp
	        ;
			表明两组exp类型和一个`+'记号在中间, 可以结合成一个更大的exp类型组.

			规则中的空白只用来分隔符号.你可以在你希望的地方添加额外的空白.

			决定规则的语义的动作可以分散在部件中.一个动组看起来是这样:

				
{C statements}
通常只有一个动作跟随着部件. 参阅 动作-Actions.

result的多种规则可以分别书写或者由垂直条`|'按如下的方法连接起来:

在这种方式下依然有我们之特考虑的特殊规则.

如果一个规则的components为空,它意味着result可以匹配空字符串. 例如,这就是一个定一个由逗号分隔的0个或多个exp组:

	
expseq:   /* empty */ /* 空 */
        | expseq1
		        ;

expseq1:  exp
        | expseq1 ',' exp
		        ;
				我们通常对每个没有部件的规则加上一个`/* empty */'的注释.


ecursive Rules
一个规则被称为递归的(recursive)当它的result非终结符也出现在它的右手边. 因为这种方法是唯一可以定义一个特定事物的任意数字序列的方法, 几乎所有的Bison语法都需要使用递归. 考虑这个逗号分隔的一个或者多个表达式的递归定义:

	
expseq1:  exp
        | expseq1 ',' exp
		        ;
				由于expseq1的递归使用是在有手端的最左符号, 我们称这种递归为左递归(left recursion). 相反地,这里有一个相同地使用右递归(right recursion)的定义.

					
				expseq1:  exp
				        | exp ',' expseq1
						        ;
								任意序列都可以使用作递归或者右递归定义, 但是通常你应该使用左递归, 因为它可以使用空间固定的栈来分析任意个数的元素序列. 由于即使规则只应用一次,在这之前,所有元素也都必须被移进到栈中, 右递归使用的Bison栈空间与序列中的元素个数成正比. 参阅 Bison分析器算法-The Bison Parser Alogorithm.获得这方面的深入解释.

								间接(Indirect)或者相互(mutual)递归当规则的结果没有在它的右手端出现 但是出现在其它右手端的非终结符规则的右手端时候发生.

								例如:

									
								expr:     primary
								        | primary '+' primary
										        ;

primary:  constant
        | '(' expr ')'
		        ;
				定义了两个相互递归的非终结符,因为它们互相引用.


3.5 定义语言的语义-Defining Language Semantics
语言的语法规则之决定了语言的语法. 语义值却是由与多种记号和组相关联的语义值和当各种组被识别时执行的动作决定的.

例如,正是由于对每个表达式关联了正确的数值,计算器才可以正确的计算. 因为组`x + y'的动作是将x和y相关联的值相加, 所以计算器能正确地计算加法
3.5.1 语义值的数据类型-Data Types of Semantic Values
在一个简单的程序中,对所有的语言结构的语义值使用同一个数据类型就足够用了. 在RPN和中缀计算器的例子中的确是这样.(参阅逆波兰记号计算器-Reverse Polish Notation Calculator一章).

Bison默认是对于所有语义值使用int类型. 如果要指明其它的类型,可以像这样将YYSTYPE定义成一个宏:
	
#define YYSTYPE double

3.5.2 多种值类型-More Than One Value Type
在大多数程序中,你需要对不同种类的记号和组使用不同的数据类型. 例如,一个数字常量可能需要类型int或long int, 而一个字符常量可能许需要类型char *, 并且一个标识符需要一个指向符号表项的指针做为其语义值的类型.

为了在一个分析器中使用多种语义值类型, Bison要求你做两件事情:

使用Bison声明%union指明全部可能的数据类型集. (参阅值类型集-The Collections of Value Types一章).
从这些类型中为每个符号(终结符或者非终结符)选择一个做为其语义值类型. 要做到这些,可以对记号使用Bison声明%token(参阅符号类型的名称-Token Type Names一章); 并且对组使用Bison声明%type(参阅非终结符-Nonterminal Symbols一章)


3.5.3 动作-Actions
当一个规则的实例被识别的时候, 同这个规则关联的包含C代码的动作会被执行. 大多数动作是用来从记号的语义值或者更小组的语义值计算整个组的语义值.

一个动作由包含在大括号之内的几个C语句构成,很像一个C语句块. 一个动作可以包含任意数量的C语句. 然而,Bison并不搜索三字符词(trigraphs), 所以如果你的代码中使用了三字符词,你要保证它不影响嵌套的括号或者注释的边界,字符串或单个字符.

一个动作可以安放在规则的任意部分; 它就在那个位置执行. 大多数规则仅有一个在规则所有部件最后的动作. 在规则之中的动作是富有技巧性的并且仅用于特殊的目的 (参阅在规则中间的动作-Actions in Mid-Rule一章).

动作中的C代码可以使用结构$n来引用匹配规则的部件的语义值. 这个结构代表了第n个部件的值. 正在被构建的组的语义值为$$. 当这些被复制到分析器文件的时候,Bison负责将这些结构翻译成适当类型的表达式. $$被翻译成一个可以修改的左值以便可以对它赋值.

这里是一个典型的例子:

	
exp:    …
        | exp '+' exp
		            { $$ = $1 + $3; }
					这个规则从两个由加号连接的稍小的exp组构建一个exp. 在这个动作中,$1和$3代着两个部件exp组的语义值. 它们是规则右手端第一个和第三个符号. 和被存储到$$以便成为刚刚被规则识别的加法表达式的语义值. 如果`+'记号有一个有用的语义值,可以通过$2引用它.

					注意到垂直杠字符`|'的确是一个分隔符, 并且动作只被附加到一个单一的规则上. 这是一点和Flex工具不同的地方. 在Flex中,`|'既代表"或者"也能代表"与下一个规则有着相同的动作". 在下面的例子中,动作仅在`b'被发现的时候触发.

						
					a-or-b: 'a'|'b'   { a_or_b_found = 1; };
如果你并没有指明一个规则的动作,Bison提供了默认的动作: $$ = $1. 因此,第一个符号的值变成了整个规则的值. 当然,仅当它们的数据类型相同时,默认动作才是有效的. 对于一个空规则,并没有有意义的默认动作; 除非这个规则的值无关紧要,否则每个空规则必须有明确的动作.

在$n的n中使用0或负值是允许的. 这使用来引用在匹配当前规则之前的栈中记号或组. 这是一个十分冒险的尝试. 你必须明确当前应用的规则处于的上下文才能可靠地使用它. 这里有一个可靠地使用这种方法的例子:

	
foo:      expr bar '+' expr  { … }
        | expr bar '-' expr  { … }
		        ;

bar:      /* empty */
        { previous_expr = $0; }
		        ;

只要bar仅仅以上面展示的形式使用, $0就总是引用先前于bar的foo的定义中的expr.


3.5.4 动作中值的数据类型-Data Types of Values in Actions
如果你为语义值只选择了一种数据类型, 那么$$和$n结构总是那种类型.

如果你已经使用了%union指定了多种数据类型, 那么你必须从这些类型中为每一个可以有语义值的终结符或非终结符声明一种. 之后当你每次使用$$或者$n的时时侯, 它的数据类型由它引用的符号的类型决定. 在这个例子中:

	
exp:    …
        | exp '+' exp
		            { $$ = $1 + $3; }
					$1和$3引用了exp的实例, 所以它们都有为非终结符exp声明的数据类型. 如果使用了$2,它就会拥有为终结符'+'声明数据类型, 无论它可能是什么.

					另外,在你引用数值的时候, 在引用的开始`$'之后插入`<type>', 你还可以指定数据类型, 例如,如果你已经定义了这里展示的数据类型:

						
					%union {
						  int itype;
						    double dtype;
					}
那么你可以用$<itype>1作为一个整数来引用规则的第一个子单元, 或者用$<dtype>1作为一个双精度数来引用.

3.5.5 规则中的动作-Actions in Mid-Rule
偶尔地,将一个动作放到规则之中是很用用处的. 这些规则的写法如同在规则之后的动作一样, 但是它们却在分析器识别之后的部件之前执行.

一个规则中动作可以通过$n来引用在它之前的部件, 但是不能引用接下来的部件,因为这个动作在它们被分析之前执行.

规则中的动作自己也作为这个规则的一个部件. 这与在同一个规则的另一个动作有些不同(另一个动作通常在结尾): 当在$n使用序号n的时候, 你必须把则个动作和符号一样也计算在内.

																									  规则中的动作也可以拥有语义值. 这个动作可以通过向$$复制来设置它的值, 并且规则之中的后一个动作可应使用$n引用这个值. 由于没有符号可以命名这个动作, 所以没有办法为这个值事先声明一个数据类型. 每当你引用这个值的时候 你必须使用`$<…>n'结构来指明一个数据类型.

																									  没有办法在规则中动作中为整个规则设定一个值, 因为对$$的赋值并没有那个效果(注:看上一段). 为整个规则赋值的唯一方法是通过规则末尾的普通动作实现.

																									  这理有一个来自假想编译器的例子,用于处理let语句. 格式为`let (variable) statement' 并在statement生存期创建一个名为variable的临时变量. 为了分析这个结构, 当statement被分析的时候,我们必须将varible放入符号表, 并在稍后移除它. 这就是这个规则如何工作的:

																										
																									  stmt:   LET '(' var ')'
																									                  { $<context>$ = push_context ();
																														                    declare_variable ($3); }
																																			        stmt    { $$ = $6;
																																						                  pop_context ($<context>5); }
																																										  一旦`let (variable)'已经被识别,第一个动作就执行. 它使用了数据类型联合中的context, 并保存了一个当前语义上下文(可访问变量列表)的副本作为它的语义值. 然后调用declare_variable来向那个列表添加新的变量. 一旦第一个动作执行完毕, 嵌入的语句stmt就可以被分析了. 注意到规则中动作的编号是5,所以`stmt'的编号为6.

																																										  在嵌入的语句stmt被分析之后,它的语义值边变为了整个let-语句的值.(注:$$=$6;) 之后,前一个动作的语义值(注$<context>5)被用来存储先前的变量列表.(注:pop_context ($<context>5)) 这将临时的let-变量从列表中删除. 这样作的目的是让它不出现在分析程序的其余部分的时候.

																																										  由于分析器为了执行动作而进行强制分析, 在一个规则没有完全被识别之前执行动作经常会导致冲突. 例如,如下的两个规则,并没有规则中的动作,可以在分析器中共存. 因为分析器可以移进一个左大括号 并且查看之后跟随的符号来确定这是否是一个声明.

																																											
																																										  compound: '{' declarations statements '}'
																																										          | '{' statements '}'
																																												          ;
																																														  但是当我们向下面这样添加一个规则中的动作时,规则就失效了:

																																															
																																														  compound: { prepare_for_local_variables (); }
																																														            '{' declarations statements '}'
																																																	        | '{' statements '}'
																																																			        ;
																																																					现在,当分析器还没有读到左到括号的时候,它就被迫决定是否执行规则中的动作. 换句话说,当分析器没有足够的信息作出正确选择的时候, 它就会强制使用一个或者其它的规则. (这个时候由于分析器仍在决定怎么办, 左大括号记号被称之为超前扫描记号(look-ahead). 参阅 超前扫描记号-Look-Ahead Token.) (注:这个时候两个规则的超前扫描记号都是`{')

																																																						你可能认为给这两个规则放置相同的动作可以解决这个问题,就像这样:

																																																								
																																																							compound: { prepare_for_local_variables (); }
																																																						          '{' declarations statements '}'
																																																									          | { prepare_for_local_variables (); }
																																																								            '{' statements '}'
																																																												        ;
																																																											但是这种方法不可行,因为Bison并没有意识到两个动作是完全相同的. (Bison永远不会尝试理解动作中的C代码.)

																																																												如果语法是这样的:可以依靠第一个记号(C语言就是这样)识别出一个声明. 那么将动作放到左大括号后是一个可行的解决方法. 就像这样:

																																																													
																																																												compound: '{' { prepare_for_local_variables (); }
																																																											          declarations statements '}'
																																																														          | '{' statements '}'
																																																																          ;
																																																													  现在接下来的声明或者语句的第一个记号(注:超前扫描记号) 在任何情况下都会告知Bison该使用哪一个规则.

																																																														  另外一种解决方法是将动作放入一个做为子规则的非终结符.

																																																															
																																																														  subroutine: /* empty */
																																																														            { prepare_for_local_variables (); }
																																																													          ;


compound: subroutine
			            '{' declarations statements '}'
						        | subroutine
								          '{' statements '}'
										          ;
		  现在Bison不用却确定最终使用的规则就可执行规则subroutine中的动作. 注意到:现在动作已经在规则的结尾. 任何规则中间的动作都可以由这种方法转化为一个规则结尾的动作, 并且这也是Bison处理规则中间的动作的方法.
