一、寄存器：
   ARM的7种处理器模式：用户usr、中断irq、快中断fiq、管理svc、中止abt、未定义und、系统sys。
   37个寄存器中是这样分的：
   R0～R7是通用的；
   R8～R12分两组，就是10个，快中断模式用一组（R8_fiq~R12_fiq)，其余的六种模式用一组（R8～R12）；
   R13、R14分六组，就是12个，其中用户模式和系统模式共用一组（R13～R14），其余的5种模式各有一组（R13_irq~R14_irq、R13_fiq~R14_fiq、R13_svc~R14_svc、R13_abt~R14_abt、R13_und~R14_und）；
   R15为七种模式共用；
   程序状态寄存器：CPSR是共用的，SPSR也是分组的，但是只有5个，因为在用户模式和系统模式下不需要SPSR；
   所以ARM状态下每种模式是18个可用（用户模式和系统模式是17个）。

二、在讲解ARM指令集前，先讲下带条件指令的条件码的含义：
   1. 条件码：{ cond }
      大部分ARM指令和Thumb分支指令包含一个条件码字段。该字段在指令用{cond}标示。
      条件指令影响程序状态字中的条件标志位。如：BEQ指令表示仅在Z标志位置位时跳转，如果{cond}段为空则无条件执行指令。
      指令描述如下：
         {cond}后缀      测试状态位           	描述
	  EQ		  Z置位			相等
	  NE		  Z清零			不相等
	  CS/HS		  C置位			无符号数大于或等于
	  CC/LO		  C清零			无符号数小于
	  MI		  N置位			负数
	  PL		  N清零			正数或0
	  VS		  V置位			溢出
	  HI		C置位，Z清零		无符号数大于
	  LS		C清零，Z置位		无符号数小于或等于
	  GE		 N等于V			带符号数大于或等于
	  LT		N不等于V		带符号数小于
	  GT		Z清零，（N等于V）	带符号数大于
	  LE		Z置位或（N不等于V）	带符号数小于或等于
	  AL		任何			无条件执行（指令默认条件）

    2. 跳转指令
      跳转指令用于实现程序流程的跳转，在ARM程序中有两种方法可以实现程式流程的跳转：使用专门的跳转指令；直接向程序计数器PC写入跳转地址值。
      通过向程序计数器PC写入跳转地址值，可以实现在4GB的地址空间中的任意跳转，在跳转之前结合使用MOV LR，PC等类似指令，可以保存将来的返回地址值，从而实现在4GB连续的线性26位地址空间的子程序使用。
      ARM指令集中的跳转指令可以完成从当前指令向前或身后的32MB的地址空间的跳转，包括以下4条指令：
      		B	跳转指令
		BL	带返回的跳转指令
		BLX	带返回和状态切换的跳转指令
		BX	带状态切换的跳转指令
         (1. B指令
	     B{条件} 目标地址
	       目标地址是相对于当前PC值的一个偏移量，而不是一个绝对地址，它的值由汇编器来计算。它是24位有符号整数，左移两位后有符号扩充为32闰，表示的有效偏移为26位（前后32MB的地址空间）。
	 (2. BL指令
	     BL{条件} 目标地址
	     BL在跳转之前，会在寄存器R14中保存PC的当前内容，因此可以透过R14的内容重新加载到PC中，返回到跳转指令之后的那条指令片执行。该指令是实现子程序使用的一个基本但常用的手段。
	 (3. BLX指令
	     BLX 目标地址
	     BLX指令从ARM指令集跳转到指令中所指定的目标地址，并将处理器的工作状态由ARM状态切换到Thumb状态，该指令同时将PC的当前内容保存到寄存器R14中。因此，当子程序使用Thumb指令集而用户使用ARM指令集时，可以透过BLX指令实现子程序的使用和处理器工作状态的切换。同时，子程序的返回可以通过将R14值复制到PC中来完成。
	 (4. BX指令
	     BX{条件} 目标地址
	     BX指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM指令，也可以是Thumb指令。


二、 数据处理指令
     数据处理指令可分为数据传送指令、算术逻辑运算指令和比较指令等。数据传送指令用于在寄存器和内在之间进行数据的双向传输。算术逻辑去处指令完成常用的自述与逻辑的运算，该类指令不但将运算结果保存在目的寄存器，同时更新CPSR中的相应条件标志位。比较指令不保存运算结果，只更新CPSR中相应的条件标志位。
     1. MOV指令
        MOV{条件}{S} 目的寄存器，来源操作数
	MOV指令完成从另一个寄存器、被移位的寄存器或将一个立即数载入到目的寄存器。其中S选项决定指令的操作是否影响CPSR中条件标志位的值。
	如：
	MOV R1，R0；MOV PC，R14；MOV R1，R0，LSL#3;(R0的值左移３位存入R1)
     2. MVN指令
        MVN{条件}{S} 目的寄存器，源操作数
	MVN指令完成从另一个寄存器、被移位的寄存器或将一个立即数载入到目的寄存器。与MOV指令不同之处是在传送前被按位取反了，即把一个被取反的值送到目的寄存器中。
	如： MVN R0, #0；将立即数0取反传送到寄存器R0中，完成后R0=-1.
     3. CMP指令
        CMP{条件} 操作数1，操作数2
	CMP指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较，同时更新CPSR中条件标志位的值。该指令进行一次减法运算，但不存储结果，只改变标志位。
	如：CMP R1，R0； CMP R1，#100；
     4. CMN指令
	CMN{条件} 操作数1，操作数2
	CMN指令用于把一个寄存器的内容和另一个寄存器的内容或立即数取反后进行比较，同时更新CPSR中条件标志位的值。
	如：CMN R1，R0；将R1的值与R0的值相加，并根据结果设定CPSR的标志位。
     5. TST指令
        TST{条件} 操作数1，操作数2
	TST用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位的与运算，并根据运算结果更新CPSR中条件标志位的值。操作数1是要测试的数据，而操作数2是一个位屏蔽，该指令一般用于测试是否设定了特定的位。
	如： TST R1，#%1；用于测试在寄存器R1中是否设定了最低位（%表示二进制数）。
     6. TEQ指令
        TEQ{条件} 操作数1， 操作数2
	TEQ指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位的互斥运算，并根据运算结果更新CPSR中条件标志位的值。该指令通常用于比较操作数1 和操作数2是否相等。
	如：TEQ R1，R2；将R1与R2的值按位互斥，并设置CPSR。
     7. ADD指令
        ADD{条件}{S} 目的寄存器，操作数1，操作数2
	ADD用于把两个操作数相加，并将结果放到目的寄存器中。操作数1就是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。
	如：ADD R0，R1，R2;R0=R1+R2
     8. ADC指令
        ADC{条件}{S} 目的寄存器，操作数1， 操作数2
	用于把两个操作数相加，再加上CPSR中的C条件标志位的值，将将结果放到目的寄存器中。它使用一个进位标志位，这样就可以做比32位大的数的加法。注意不要忘记设定S后缀来更改进位标志。以下指令序列完成两个128位数的加法，运算结果由高到低存放在寄存器R3－R0中。
	如：ADDS R0，R4，R8；加低端的字
	    ADCS R1，R5，R9；加第二个字，带进位
	    ADCS R2，R6，10；加第三个字，带进位
	    ADCS R3，R7，R11；加第四个字，带进位
     9. SUB指令
        SUB{条件} 目的寄存器，操作数1，操作数2
	用于把操作数1减去操作数2，并将结果放到目的寄存器中。运算元1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令可用于有符号数或无符号数的减法运算。
	如：SUB R0，R1，R2；R0＝R1－R2
	    SUB R0，R1，#256；R0＝R1－256
	    SUB R0，R2，R3，LSL#1；R0＝R2－（R3<<1）
     10. SBC指令
         SBC{条件}{S} 目的寄存器，操作数1，操作数2
	 SBC指令用于把操作数1减去操作数2，再减去CPSR中的C条件标志位的反码，并将结果放到目的寄存器中。操作数1应该是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令使用进位标志来表示借位，这样做可以做大于32位的减法，注意不要忘了设定S后缀来更改进位标志。
	 如：SUBS R0，R1，R2；R0=R1-R2-!C，并根据结果来设定CPSR的进位标志位32
      11. RSB指令
          RSB{条件}{S} 目的寄存器，操作数1，操作数2
	  RSB指令称为逆向减法指令，用于把操作数2送去操作数1，并将结果存放到目的寄存器中。操作数1应该是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令可用于有符号数或无符号数的减法运算。
	  如：RSB R0，R1，R2； R0=R2-R1
      12. RSB指令
          RSC{条件}{S} 目的寄存器，操作数1，操作数2
	  RSC指令用于把操作数2减去操作数1，再送去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器中。同样，对于寄存器1、2要求是一样的。该指令使用进位标志来表示借位，这样做可以做大于32位的减法，注意不要忘记设定S后缀来更改进位标志。该指令可用于有符号数或无符号数的减法运算。
	  如：RSC R0，R1，R2； R0=R2-R1-!C
      13. AND指令
          AND{条件}{S} 目的寄存器，操作数1，操作数2
	  逻辑与运算。该指令常用于屏蔽操作数1的某些位。
	  如：AND R0，R0，#3；保持R0的0、1位，其余位清零。
      14. ORR指令
          ORR{条件}{S} 目的寄存器，操作数1，操作数2
	  逻辑或运算。该指令常用于设定操作数1的某些位。
	  如：ORR R0，R0，#3； 设定R0的0、1位，其余位保持不变。
      15. EOR指令
          EOR{条件}{S} 目的寄存器，操作数1，操作数2
          逻辑互斥运算。常用于反转操作数1的某些位。
	  如：EOR R0，R0,#3；反转R0的0、1位，其余位保持不变。
      16. BIC指令
          BIC{条件}{S} 目的寄存器，操作数1，操作数2
	  BIC指令用于清除操作数1的某些位，并把结果放置到目的寄存器中。操作数2为32位的屏蔽。如果在屏蔽中设定了某一位，则清除这一位，未设定的屏蔽位保持不变。
	  如：BIC R0,R0,#%1011；该指令清除R0中的位0、1、3，其余位保持不变。

三、乘法指令与乘加指令
    ARM微处理器支持的乘法指令与乘加指令共有6条，可分为运算结果为32位和运算结果为64位两类。与前面的数据处理指令不同，指令中的所有操作数、 、目的操作数必须为通用寄存器，不能对操作数使用立即数或被移位的寄存器，同时，目的寄存器和操作数1必须是不同的寄存器。乘法指令与乘加指令共有以下6条：
        MUL 32位乘法指令
	MLA 32位乘加指令
	SMULL 64位有符号数乘法指令
	SMLAL 64位有符号数乘加指令
	UMULL 64位无符号数乘法指令
	UMLAL 64位无符号数乘加指令
    1. MUL指令
       MUL{条件}{S} 目的寄存器，操作数1，操作数2
       操作数1与操作数2相乘，并把结果放置到目的寄存器中，同时可以根据运算结果设定CPSR中相应的条件标志位。
       如：MUL R0，R1，R2；R0=R1xR2
           MULS R0,R1, R2; R0=R1xR2，同时设定CPSR中的相关条件标志位
     2. MLA指令
        MLA{条件}{S} 目的寄存器，操作数1，操作数2，操作数3
	操作数1与操作数2相乘，再加上操作数3并把结果放置到目的寄存器中，同时可以根据运算结果设定CPSR中相应的条件标志位。
	如：MLA R0，R1，R2，R3； R0=R1xR2+R3
     3. SMULL指令
        SMULL{条件}{S} 目的寄存器Low，目的寄存器High，操作数1，操作数2
	SMULL指令完成操作数1与操作数2的乘法运算，并把结果的低32位元放置到目的寄存器Low中，结果的高32位放置到目的寄存器High中，同时可以根据运算结果设定CPSR中相应的条件标志位。
	如：SMULL R0，R1，R2，R3；R0＝(R2xR3)的低32位；
	                          R1=(R2xR3)的高32位。
     4. SMLAL指令
        SMLAL{条件}{S} 目的寄存器Low，目的寄存器High，操作数1，操作数2
	SMLAL指令完成操作数1与操作数2的乘法运算，并把结果的低32位元同目的寄存器low的值相加后放置到目的寄存器low中，结果的高32位同目的寄存器High中的值相加后又放置到目的寄存器high中，同时可以根据运算结果设定CPSR中相应的条件标志位。其中，操作数1和操作数2均为32位的有符号数。对于目的寄存器low，在指令执行前存放64位加数的低32位，指令执行后存放结盟的低32位；而在目的寄存器high中存放64位加数的高32位。
	如：SMLAL R0，R1，R2，R3； R0=(R2xR3)的低32位＋R0
				   R1=(R2xR3)的高32位＋R1.
     5. UMULL指令
        UMULL{条件}{S} 目的寄存器Low，目的寄存器High，操作数1，操作数2
	UMULL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位元放置到目的寄存器的low中，结果的高32位放置到目的寄存器的high中。
	如：UMULL R0,R1,R2,R3; R0=(R2xR3)的低32位
			       R1=(R2xR3)的高32位.
     6. UMLAL指令
        UMLAL{条件}{S} 目的寄存器Low，目的寄存器High，操作数1，操作数2
	同SMLAL，只不过操作1和操作数2无谓32位的无符号整数。

四、程序状态寄存器存取指令
    ARM微处理器支持程序状态寄存器存取指令，用于在程序状态寄存器和通用寄存器之间传送数据。程序状态寄存器存取指令包括以下两条：
      MRS  程序状态寄存器到通用寄存器的数据传送指令。
      MSR  通用寄存器到程序状态寄存器的数据传送指令。

      1. MRS
         MRS{条件} 通用寄存器，程序状态寄存器（CPSR或SPSR）
	 MRS指令用于将程序状态寄存器的内容传送到通用寄存器中。该指令一般用在以下几种情况：
	 当需要改变程序状态寄存器的内容时，可用MRS将程序状态寄存器的内容诗篇通用寄存器，修改后再写回程序状态寄存器。
	 当在例外处理或行程切换时，需要保存程序状态寄存器的值。可先用该指令读出程序状态寄存器的值，然后保存。
	 如：
	 	MRS R0， CPSR；
       2. MSR
          MSR{条件} 程序状态寄存器（CPSR或SPSR）_<域>，操作数
	  MSR指令用于将操作数的内容传送室程序状态寄存器的特定域中。其中，操作数可以为通用寄存器或立即数。<域>用于设定程序状态寄存器中需要操作的位，32位的程序状态寄存器可分为4个域：
	     位[32:24]为条件标志域，用f表示；
	     位[23:16]为状态位域，用s表示；
	     位[15:8]为扩充位域，用x表示；
	     位[7:0]为控制位域，用c表示。
	   该指令通常用于恢复或改变程序状态寄存器的内容，在使用时，一般要在MSR指令中指明将要操作的域。
	   如：MSR CPSR，R0； 传送R0的内容到CPSR
	       MSR CPSR_c, R0; 传送R0的内容到CPSR，但仅仅修改CPSR中的控制位域。

五、加载/存储指令
    ARM微处理器支持加载/存储指令用于在寄存器和存储器之间传送数据，加载指令用于将存储器中的数据传送到寄存器，存储指令则完成相反的操作。常用的加载存储指令如下：
      1. LDR指令
         LDR{条件} 目的寄存器，存储器地址
	LDR指令用于从存储器中将一个32位字数据传送到目的寄存器中。该指令通常用于从存储器中读取32位的字数据到通用寄存器，然后对数据进行处理。当PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程跳转。	    如：
            LDR R0，[R1]; 将存储器地址为R1的字数据读入寄存器R0
            LDR R0，[R1, R2]; 将存储器地址为R1+R2的字数据读入寄存器R0
	    LDR R0，[R1,#8];  将存储器地址为R1+8的字数据读入寄存器R0
	    LDR R0, [R1, R2]!; 将存储器地址为R1+R2的字数据读入寄存器R0，并将新地址R1+R2写入R1
	    LDR R0, [R1], R2; 将存储器地址为R1的字数据读入寄存器R0，并将新地址R1+R2写入R1
	    LDR R0, [R1, R2, LSL#2]!; 将存储器地址为R1+R2x4的字数据读入寄存器R0，并将新地址R1+R2x4写入R1.
	    LDR R0, [R1], R2, LSL#2； 将存储器地址为R1的字数据读入寄存器R0，并将新地址R1+R2x4写入R1.
        2.  LDRB/LDRH
            LDR{条件}B/H 目的寄存器，存储器地址
            将8/16位的字节数据传送到睥睨我寄存器，同时将寄存器的高24/16位清零。
	3. STR指令
	   STR{条件} 源寄存器，存储器地址
	   STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。该指令在程序设计中比较常用。
	   如： STR R0, [R1], #8; 将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1.
	        STR R0，[R1,#8]; 将R0中的字数据写入以R1＋8为地址的存储器中。
	4. STRB/STRH
	   STR{条件}B/H 源寄存器，存储器地址
	   从源寄存器中将一个8/16位的数据传送到存储器中。

六、批量数据加载/存储指令
    ARM微处理器所支持批量数据加载/存储指令可以在一片连续的存储单元和多个寄存器之间传送数据，批量加载指令用于将一片连续的存储器中的数据传送到多个寄存器，批量数据存储指令则完成相反的操作。常用的加载存储指令如下：
     1. LDM/STM指令
        LDM/STM{条件}{类型} 基址寄存器{!}，寄存器列表{^}
	LDM/STM指令用于从由基址寄存器所指示的一片连续存储器到寄存器列表所指示的多个寄存器之间传送数据，该指令的常见用途是将多个寄存器的内容入栈或出栈。其中，类型为以下几种情况：
	  IA  每次传送后地址加1；
	  IB  每次传送前地址加1；
	  DA  每次传送后地址减1；
	  DB  每次传送前地址减1；
	  FD  滿递减堆栈；
	  ED  空递减堆栈；
	  FA  滿递增堆栈；
	  EA  空递减堆栈；
	 {!}为可选后缀，若选用该后缀，则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。
	 基址寄存器不允许为R15，寄存器列表可以为R0～R15的任意组合。
	 {^}为可选后缀，当指令为LDM且寄存器列表中包含R15，选用该后缀表示：除了正常的数据传送之外，还将SPSR复制到CPSR。同时，该后缀还表示传入或传出的是用户模式下的寄存器，而不是当前模式下的寄存器。
	 如：STMFD R13!, {R0, R4-R12, LR}; 将寄存器列表中的寄存器（R0,R4~R12,LR)存入堆栈。
	     LDMFD R13!, {R0, R4-R12, PC}; 将堆栈内容恢复到寄存器(R0,R4~R12,PC)。

七、数据交换指令
    1. SWP指令
       SWP{条件} 目的寄存器，源寄存器1，[源寄存器2]
       SWP指令用于将源寄存器2所指向的存储器中的字数据传送到目的寄存器中，同时将源寄存器1中的字数据传送到源寄存器2所指向的存储器中。显然，当源寄存器1和目的寄存器为同一个寄存器时，指令交换该寄存器的存储器的内容。
       如：SWP R0，R1，[R2]; 将R2所指向的存储器中的字数据传送到R0，同时将R1中的字数据传送到R2所指向的存储单元。
           SWP R0，R0，[R1]; 将R1所指向的存储器中的字数据与R0中的数据交换。
    2. SWPB指令
       SWP{条件}B 目的寄存器，源寄存器1，[源寄存器2]
       SWPB指令用于将源寄存器2所指向的存储器中的字节数据传送到目的寄存器中，目的寄存器的高24清零，同时将源寄存器1中的字节数据传送到源寄存器2所指向的存储器中。
       如：SWPB R0，R1，[R2]；将R2所指向的存储器中的字节数据传送到R0，R0的高24位清零，同时将R1中的低8位数据传送到R2所指向的存储单元。

八、移位指令
    1. LSL／ASL操作
       通用寄存器，LSL/ASL 操作数
       LSL/ASL可完成对通用寄存器中的内容进行逻辑/自述的左移操作，按操作数所指定的数量向左移位，低位用零来填充。其中，操作数可以是通用寄存器，也可以是立即数(0~31)。
       如：MOV R0，R1，LSL#2；将R1中的内容左移两位后传送后R0中。
    2. LSR操作
       通用寄存器，LSR 操作数
       完成对通用寄存器中的内容进行右移的操作，按操作数所指定的数量向右移位，左端用零来填充。其中，操作数可以是通用寄存器，也可以是立即数(0~31)。
       如：
           MOV R0，R1，LSR#2;  将R1中的内容右移两位后传送到R0中，左端用0来填充
    3. ASR操作
       通用寄存器，ASR 操作数
       ASR可完成对通用寄存器中的内容进行右移的操作，按操作数所指定的数量向右移位，左端用第31位的值来填充。其中，操作数可以为通用寄存器或立即数（0~31)。
       如：MOV R0，R1，ASR#2; 将R1中的内容右移两位后传送到R0中，左端用第31来填充。
    4. ROR操作
       通用寄存器，ROR 操作数
       ROR可完成对通用寄存器中的内容进行循环右移的操作，按操作数所指定的数量向右循环移位，左端用右端移出的位来填充。其中，操作数可以为通用寄存器或立即数（0~31)。显然，当进行32位的循环右移操作时，通用寄存器中的值不改变。
       如：MOV R0，R1，ROR＃2；将R1中的内容循环右移两位后传送到R0中。
    5. RRX操作
       通用寄存器，RRX 操作数
       RRX可完成对通用寄存器中的内容进行带扩展的循环右移操作，按操作数所指定的数量向右循环移位，左端用进位标志C来填充。
       如：MOV R0，R1，RRX#2; 将R1中的内容进行带扩展的循环右移两位后传送到R0中。

九、协处理器指令
    1. CDP指令
       CDP{条件} 协处理器编码，协处理器操作码1，目的寄存器，源寄存器1，源寄存器2，协处理器操作码2.
       CDP指令用于ARM处理器通知ARM协处理器执行特定的操作，若协处理器不能成功完成特定的操作，则产生未定义指令异常。其中协处理器操作码1和协处理器操作码2为协处理器要执行的操作，目的寄存器和源寄存器均为处理器的寄存器，指令不涉及ARM处理器的寄存器和存储器。
       如：CDP P3，2，C12，C10，C3，4；该指令完成协处理器P3的初始化。
    2. LDC指令
       LDC{条件}{L} 协处理器编码，目的寄存器，[源寄存器]
       LDC指令用于将源寄存器所指向的存储器中的字数据传送到目的寄存器中，若协处理器不能成功完成传送操作，则产生未定义指令异常。其中，{L}选项表示指令为长读取操作，如用于双精度数据的传输。
       如：LDC P3，C4，[R0]；将ARM处理器的寄存器R0所指向的存储器中的字数据传送到协处理器P3的寄存器C4中。
    3. STC指令
       STC{条件}{L} 协处理器编码，源寄存器，[目的寄存器]
       STC指令用于将源寄存器中的字数据传送到目的寄存器所指向的存储器中，或协处理器不能完成传送操作，则产生未定义指令异常。其中，{L}选项表示指令为长读取操作，如用于双精度数据的传输。
       如：STC P3，C4，[R0]; 将协处理器P3的寄存器C4中的字数据传送到ARM处理器的寄存器R0所指向的存储器中。
    4. MCR指令
       MCR{条件} 协处理器编码，协处理器操作码1，源寄存器，目的寄存器1，目的寄存器2，协处理器操作码2
       MCR指令用于将ARM处理器寄存器中的数据传送到协处理器寄存器中，若协处理器不能成功完成操作，则产生未定义指令异常。其中协处理器操作码1和协处理器操作码2为协处理器要执行的操作，源寄存器为ARM处理器的寄存器，目的寄存器1和目的寄存器2均为协处理器的寄存器。
       如：MCR P3,3,R0,C4,C5,6; 该指令将ARM处理器寄存器R0中的数据传送到协处理器P3的寄存器C4和C5中。
    5. MRC指令
       MRC{条件} 协处理器编码，协处理器操作码1，目的寄存器，源寄存器1，源寄存器2，协处理器操作码2.
       MRC指令用于将协处理器寄存器中的数据传送到ARM处理器寄存器中，若协处理器不能成功完成操作，则产生未定义指令异常。其中协处理器操作码1和协处理器操作码2为协处理器要执行的操作，目的寄存器为ARM处理器的寄存器，源寄存器1和源寄存器2均为协处理器的寄存器。
       如：
       MRC P3，3，R0，C4，C5，6；该指令将协处理器P3的寄存器中的数据传送到ARM处理器寄存器中。

十、异常产生指令
     1. SWI指令
        SWI{条件} 24位的立即数
	SWI指令用于产生软件中断，以便用户程序能调用操作系统的系统例程。操作系统在SWI的异常处理程序中提供了相应的系统服务，指令中的24位立即数指定用户程序调用系统例程的类型，相关参数通过通用寄存器传送，当指令中24位的立即数被忽略时，用户程序调用系统例程的类型由通用寄存器R0的内容决定，同时，参数通过其他通用寄存器传送。
	如： SWI 0x02; 调用操作系统编号为02的系统调用。
      2. BKPT指令
         BKPT 16位的立即数
	 BKPT指令产生软件断点中断，可用于程序的调试。

十一、ARM汇编器所支持的伪指令
      在ARM汇编语言程序里，有一些特殊指令助记符，这些助记符与指令系统的助记符不同，没有相对的操作码，通常称这些特殊指令助记符为伪指令，它们所完成的操作称为伪操作。伪指令在源程序中的作用是为完成汇编程序作各种准备工作的，这些伪指令仅在汇编过程中起作用，一旦汇编结束，伪指令的使命就完成了。
      在ARM的汇编程序中，有如下4种伪指令：符号定义伪指令、数据定义伪指令、汇编控制伪指令、宏指令以及其他伪指令。
      （一、符号定义伪指令
       符号定义伪指令用于定义ARM汇编程序中的变量、对变量赋值以及定义寄存器的别名等操作。常见的符号定义伪指令有如下4种：
        1. GBLA、GBLL和GBLS
	   GBLA/GBLL/GBLS 全书变量名
	   用于定义一个ARM程序中的全局变量，并将其初始化。其中：
	   GBLA用于定义一个全局的数字变量，并初始化为0；
	   GBLL用于定义一个全局的逻辑变量，并初始化为F（假）；
	   GBLS用于定义一个全局的字符串变量，并初始化为空；
	   在整个程序范围内变量名必须唯一。
	   如：
	       GBLA Test1 ;定义一个全局的数字变量，名为Test1
	       Test1 SETA 0xaa ;将变量赋值为0xaa
	       GBLL Test2; 定义一个全局的逻辑变量，变量名为Test2
	       Test2 SETL {TRUE}; 将该变量赋值为真
	       GBLS Test3; 定义一个全局的字符串变量，变量名为Test3
	       Test3 SETS "Testing"  ;将变量赋值为“Testing”
	 2. LCLA、LCLL和LCLS
	    LCLA/LCLL/LCLS 局部变量名
	    定义一个ARM程序中的局部变量，并将其初始化。
	    LCLA用于定义一个局部的数字变量，并初始化为0；
	    LCLL用于定义一个局部的逻辑变量，并初始化为F（假）；
	    LCLS用于定义一个局部的字符串变量，并初始化为空；
	    在其作用范围内变量名必须唯一。
	    如：
	        LCLA Test4；
         3. SETA、SETL和SETS
	    变量名 SETA/SETL/SETS 表达式
	    用于给一个已经定义的全局变量或局部变量赋值。

	 4. RLIST
	    名称 RLIST {寄存器列表}
	    可用于对一个通用寄存器列表定义名称，使用该伪指令定义的名称可在ARM指令LDM/STM中使用。在LDM/STM指令中，列表中寄存器访问次序为根据寄存器的编号由低到高，而与列表中的寄存器排列次序无关。
	    如：
	      RegList RLIST {R0-R5,R8,R10}; 将寄存器列表定义为RegList,可在ARM指令LDM/STM中通过该名称访问寄存器列表。
   
      （二、数据定义伪指令
        数据定义伪指令一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化。常用的数据定义伪指令有如下9种：
          1. DCB
              标号  DCB  表达式
              DCB用于分配一片连续的字节存储单元并用伪指令中指定的表达式初始化。其中表达式可以为0～255的数字或字符串。DCB也可用“＝”代替。
              如：
                  Str DCB “THIS IS A TEST！”；分配一片连续的字节存储单元并初始化。
          2. DCW/DCWU
              标号  DCW/DCWU 表达式
              DCW/DCWU用于分配一片连续的半字存储单元并用伪指令中指定的表达式初始化。其中，表达式可以为程序标号或数字表达式。用DCW分配的字存储单元是半字对齐的，而DCWU分配的字存储单元并不严格半字对齐。
  	      如：
　　　　　　　　　DataTest  DCW  1，2，3；分配一片连续的半字存储单元并初始化。
          3. DCD/DCDU
	      标号  DCU/DCDU 表达式
	      分配一片连续的字存储单元并用伪指令中的指定表达式初始化。其中，表达式可以为程序标号或数字表达式。DCD也可用“＆”代替。用DCD分配的字存储单元是字对齐的，而用DCDU分配的字存储单元并不严格字对齐。
	      如：DataTest DCD 4，5，6；
	  4. DCFD/DCFDU
	      标号 DCFD/DCFDU 表达式
	      DCFD/DCFDU用于为双精度的浮点数分配一片连续的字存储单元。每个双精度的浮点数占据两个字单元。
	      如：FDaataTest DCFD 2E115，-4E7；
	  5. DCFS/DCFSU
	      标号 DCFS/DCFSU 表达式
	      为单精度的浮点数分配一片连续的字存储单元。每个单精度的浮点数占据一个字单元。
	      如： FDataTest DCFS 2E5, 5E-7;
	  6. DCQ/DCQU
	      标号  DCQ／DCQU 表达式
	      分配一片以8个字节为单位的连续存储区域。
	      如：DataTest DCQ 100;
	  7. SPACE
	      标号  SPACE 表达式
	      分配一片连续的存储区域并初始化为0.其中，表达式为要分配的字符数。SPACE也可用%代替。
	      如：DataSpace SPACE 100；分配连续100字节的存储单元并初始化为0.
	  8. MAP
	      MAP 表达式{,基址寄存器}
	      MAP用于定义一个结构化的内存表的首地址。MAP也可用"^"代替。表达式可以为程序中的标号或数学表达式，基址寄存器为可选项，当基址寄存器选项不存在时，表达式的值即为内存表的首地址，当该选项存在时，内存表的首地址为表达式的值为基址寄存器的和。MAP通常与FIELD伪指令配合使用来定义结构化的内存表。
	      如：MAP 0x100,R0; 定义结构化内存表首地址的值为0x100+R0.
	  9. FIELD
	      标号  FIELD 表达式
	      用于定义一个结构化内存表中的数据域。FIELD也可用"#"代替。表达式的值为当前数据域在内存表中所占的字节数。MAP伪指令定义内存表的首地址，FIELD用于定义内存表中的各个数据域，并可以为每个数据域指定一个标号供其他的指令引用。注意，MAP和FIELD仅用于定义数据结构，并不实际分配存储单元。
	       使用：
	          MAP 0x100   ;定义结构化内存首地址的值为0x100
		  A FIELD 16  ;定义A的长度为16字节，位置为0x100
		  B FIELD 31  ;定义B的长度为32字节，位置为0x110
      （三、汇编控制伪指令
            用于控制汇编程序的执行流程，常用的汇编控制伪指令包括以下4条：
	    1. IF、ELSE、ENDIF
	       格式：
	            IF 逻辑表达式
		        指令序列1
		    ELSE
		    	指令序列2
		    ENDIF
	       比如：
	           GBLL Test
		   ....
		   IF Test = TRUE
		       ...
		   ELSE
		       ...
		   ENDIF
	     2. WHILE、WEND
	        格式：
		   WHILE 逻辑表达式
		        指令序列
	           WEND
	     3. MACRO、MEND
	        格式：
		    $标号  宏名 $参数1，$参数2，...
		       指令序号
		    MEND
		 用于将一段代码定义为一个整体，称为宏指令。然后就可以在程序中通过宏指令多次调用该段代码。其中，$标号在宏指令被展开时，标号会被替换为用户定义的符号，宏指令可以使用一个或多个参数，当宏指令被展开时，这些参数被相应的值替换。宏指令的使用方式和功能与子程序有些相似，子程序可以提供模块化的程序设计、节省存储空间并提高运行速度，但在使用子程序结构时需要保护现场，从而增加了系统开销，因此，在代码较短且需要传递的参数较多时，可以使用宏指令代替子程序。
	      4. MEXIT
	         MEXTI用于从宏定义中跳转出去。
     （四、其他常用的伪指令
           其他常用的伪指令包括以下13条：
	       1. AREA
	          格式：
		     AREA 段名 属性1，属性2，...
		   AREA县城定义一个代码段或数据段。其中，段名若以数字开关，则该段名需用"|"括起来，如|1_test|。属性字段表示该代码段（或数据段）的相关属性，多个属性用逗号分隔。常用的属性如下：
		    * CODE属性：用于定义代码段，默认为READONLY
		    * DATA属性: 用于定义数据段，默认为READWRITE
		    * READONLY属性：指定本段为只读
		    * READWRITE属性：指定本段为可读可写
		    * ALIGN属性：使用方式为ALIGN表达式。在默认时，ELF的代码段和数据段是按字对齐的，表达式的取值范围为0~31，相应的对齐方式为2表达次方。
		    * COMMON属性：该属性定义一个通用的段，不包含任何的用户代码和数据。各源文件中同名的COMMON段共享同一段存储单元。一个汇编语言程序至少要包含一个段，当程序太长时，也可以将程序分为多个代码段和数据段。
		    如：
		      AREA Init,CODE,READONLY ；定义一个名为init的代码段
		2. ALIGN
		   ALIGN {表达式{, 偏移量}}
		   用于通过添加填充字节的方式，使当前位置满足一定的对齐方式。其中，表达式的值用于指定对齐方式，可能的取值为2的幂，如1、2、4、8，16.若未指定表达式，则将当前位置对齐到下一个字的位置。偏移量也为一个数字表达式，若使用该字段，则当前位置的对齐的方式为：2的表达式次幂＋偏移量。
		   如： 
		      AREA Init,CODE,READONLY,ALIEN=3 ；指定后面的指令为8字节对齐
		          指令序列
		      END

		3. CODE16、CODE32
		   CODE16伪指令通知编译器，其后的指令序列为16位的Thumb指令。
		   CODE32伪指令通知编译器，其后的指令序列为32位的ARM指令。
		4. ENTRY
		   用于指定汇编程序的入口点。在一个完整的汇编程序中，至少要有一个ENTRY（也可以有多个，当有多个ENTRY时，程序的真正入口点由链接器指定），但在一个源文件里最多只能有一个ENTRY（可以没有）。
		   如：
		      AREA Init,CODE,READONLY ；定义一个名为init的代码段
		      ENTRY	;指定应用程序入口点
		      ....
		5. END
		   用于通知编译器已经到了源程序的结尾。
		6. EQU
		   名称 EQU 表达式{,类型}
		   EQU可用“＊”代替。类似于C中的#define，为程序中的常量、标号等定义一个等效的字符名称。当表达式为32位的常量时，可以指定表达式的数据类型，可以有如下三种类型：CODE16、CODE32和DATA。
		   如：
		     Test EQU 50     ；定义标号TEST的值为50
		     Addr EQU 0x55,CODE32 ；定义Addr的值为0x55,且该处为32位的ARM指定。
		7. EXPORT/GLOBAL
		    EXPORT 标号 {[WEAK]}
		    用于在程序中声明一个全局的标号，该标号可在其他的文件中引用。EXPORT可用GLOBAL代替。标号在程序中区分大小写，[WEAK]选项声明其他的同名标号优先于该标号被引用。
		8. IMPORT
		   IMPORT 标号{[WEAK]}
		   用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用，而且无论当前源文件是否引用该标号，该标号均会被加入到当前源文件符号表中。
		9. EXTERN
		   EXTERN 标号{[WEAK]}
		   用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用，如果当前源文件实际并未引用该标号，该标号就不会被加入到当前源文件的符号表中。
		10. GET/INCLUDE
		    GET 文件名
		    用于将一个源文件包含到当前的源文件中，并将新官上任以包含的源文件在当前位置进行汇编处理。可以使用INCLUDE代替GET。汇编程序中常用的方法是在某源文件中定义一些宏指令，用EQU定义常量的符号名称，用MAP和FIELD定义结构化的数据类型，然后用GET伪指令将这个源文件包含到其他的源文件中。使用方法与C语言中的include相似。GET伪指令只能用于包含源文件，包含目标文件需要使用INCBIN伪指令。
		11. INCBIN
		    INCBIN 文件名
		    用于将一个目标文件或数据文件包含到当前的源文件中，被包含的文件不作任何变动的存放在当前文件，编译器从其后开始继续处理。
		12. RN
		    名称 RN 表达式
		    用于给一个寄存器定义一个别名。采用这种方式可以方便程序员记忆该寄存器的功能。其中，名称为给寄存器定义的别名，表达式为寄存器的编码。
		    如：TEMP RN R0；将R0定义为一个别名TEMP
		13. ROUT
		    {名称} ROUT
		    用于给一个局部变量定义作用范围。在程序中未使用该伪指令时，局部变量的作用范围为所在的AREA，而使用ROUT后， 局部变量的作用范围为当前ROUT和下一个ROUT之间。
		   
	       
	 

