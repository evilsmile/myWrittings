SECTIONS{
	...
	secname start BLOCK(align) (NOLOAD) : AT(ldadr)
	{ contents } > region : phdr = fill
	...
}
 secname和contents是必须的，其他都是可选的，
 1. secname: 段名
 2. contents: 决定哪些内容放在本段，可以是整个目标文件，也可以是目标文件中的某段（代码段、数据段等）
 3. start: 本段（运行）的地址，如果没有使用AT(ldadr)，本段存储的地址也是start。
 4. AT(ldadr): 定义本段存储（加载）的地址。
   如：SECTIONS{
	   first 0x000000: { head.o init.o}
	   second 0x300000: AT(4096) { main.o }
   }
   head.o放在0x000000地址开始片，init.o放在head.o后面，他们的运行地址也是0x000000，即连接和存储地址相同（没有AT指定）；main.o放在4096(0x1000，是AT指定的存储地址）开始处，但是它的运行地址在0x300000，运行之前需要从0x1000（加载处）复制到0x300000（运行处），此过程也就用到了读取Nand flash.
   这就是存储地址和连接（运行）地址的不同，称为加载时域和运行时域，可以在.lds连接脚本文件中分别指定。


   什么是编译地址？什么是运行地址？
   32位的处理器，它的每一个指令是4个字节，以4个字节存储顺序，进行顺序执行，CPU是顺序执行的，只要没发生什么跳转，它会顺序进行执行，编译器会对每一条指令分配一个编译地址，这是编译器分配的，在编译过程中分配的地址，我们称之为编译地址。
   运行地址是指程序指令真正的运行地址，是由用户指定的，用户将运行地址烧录到哪里，哪里就是运行的地址。比如有一个指令的编译地址是0x5，实际运行的地址是0x200，用户将指令烧到0x200上，那么这条指令的运行地址就是0x200，当编译地址和运行地址不同时出现的结果就是，不能跳转。编译后会产生跳转地址，如果实际地址和编译后的地址不相等，那么就不能跳转。C语言编译地址都希望把编译地址和实际运行地址放在一起，但是汇编代码因为不需要做C语言到汇编的转换，可以人为地去写地址，所以直接写的就是他的运行地址。编译地址和运行地址如何来算呢？假如有两个编译地址a=0x10,b=0x7，b的运行地址是0x300，那么a的运行地址就是b的运行地址加上两者编译地址差值，a-b=0x10-0x07=0x3，a的运行地址就是0x300+0x3=0x303.

   为什么要分配编译地址？这样做有什么好处，有什么作用？
   比如在函数a中定义了函数b，当执行到函数b时要进行指令跳转，要跳转到b函数对应的起始地址上去，编译时，编译器给每条指令都分配了编译地址，如果编译器已经给分配了地址就可以直接进行跳转，查找b函数跳转指令所对应的表，进行直接跳转，因为有个编译地址和指令对应的一个表，如果没有分配，编译器就查不到这个跳转地址，要进行计算，非常麻烦。
    
   什么是相对地址？
   以NOR Flash为例，NOR Flash是映射到bank0上面，SDRAM是映射到bank6上面，uboot和内核最终是在SDRAM上运行，最开始我们是从Nor Flash的零地址开始往后烧录，uboot中至少有一段代码编译地址和运行地址是不一样的，编译uboot或内核时，都会将编译地址放入到SDRAM中，他们最终都会在SDRAM中执行，刚开始uboot在Nor Flash中运行，运行地址是一个低端地址，是bank0中的一个地址，但编译地址是bank6中的地址，这样就会导致绝对跳转指令执行的失败，所以就引出相对地址的概念。至少在bank0中uboot这段代码要知道不能用b+编译地址这样的方法去跳转指令，因为这段代码的编译地址和运行地址不一样，那就要去计算这个指令运行的真实地址，计算出来后再做跳转，应该是b+运行地址，不能出现b+编译地址，而是b+运行地址，而运行地址是算出来的。

