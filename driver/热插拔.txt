将可移动设备连入系统时，系统的后台中会依次发生如下事件：
         内核检测到新硬件插入，然后分别通知hotplug和udev。前者用来装入相应的内核模块(如usb-storage)，而后者用来在/dev中创建相应的设备节点(如/dev/sda1)。
         udev创建了相应的设备节点之后，会将这一消息通知hal的守护程序(hald)。当然udev还得保证新创建的设备节点可以被普通用户访问。
         hotplug装入了相应的内核模块之后，会把这一消息通知给hald。
         hald在受到hotplug和udev发出的消息之后，认为新硬件已经正式被系统认可了。此时它会通过一系列精心编写的规则文件（就是传说中的xxx-policy.fdi），把发现新硬件的消息通过dbus发送出去，同时还会调用update-fstab或fstab-sync来更新/etc/fstab，为相应的设备节点创建适合的挂载点。
         卷管理器会监听dbus中发现新硬件的消息。根据所插入的硬件(区分U盘和数码相机等)不同，卷管理器会先将相应的设备节点挂载到hald创建的挂载点上，然后再打开不同的应用程序。
当然，如果是在CDROM中插入光盘，过程可能比较简单。因为CDROM本身就是一个固定的硬件，无需hotplug和udev的协助：
         hald会自己监视CDROM，并且将光盘托架开合的消息通过dbus发出去。
         卷管理器负责检查CDROM中的盘片内容，进行挂载，并调用合适的应用程序。
要注意，hald的工作是从上游得到硬件就绪的消息，然后将这个消息转发到dbus中。尽管它会调用程序来更新fstab，但实际上它自己并不执行挂载的工作 
下面是上面的过程中涉及的模块和工具：
         hotplug
hotplug 包和内核里的hotplug模块不是一回事，2.6内核里的pci_hotplug.ko是一个内核模块，而hotplug包是用来处理内核产生的hotplug事件。这个软件包还在引导时检测现存的硬件并在运行的内核中加载相关模块。
不但有热插拔，还有冷插拔（cold pluging）。热插拔在内核启动之后发生，而“cold pluging”发生在内核启动的过程中。
/etc/hotplug/*.rc 这些脚本用于冷插拔(检测和激活在系统启动时已经存在的硬件)。它们被 hotplug 初始化脚本调用。*.rc 脚本会尝试恢复系统引导时丢失的热插拔事件，举例来说，内核没有挂载根文件系统。
	      /etc/hotplug/*.agent这些脚本将被 hotplug 调用以响应内核产生的各种不同的热插拔事件，导致插入相应的内核模块和调用用户预定义的脚本。
	      /sbin/hotplug内核默认情况下将在内核态的某些事情发生变化时(如硬件的插入和拔出)调用此脚本。
	      发送热插拔事件的子系统（subsystem）包括总线驱动（USB、PCI等）和一些设备的抽象层（网络接口、磁盘分区等）。它们通过/sbin/hotplug的第一个参数来识别。
	      对于设备驱动来说，需要在代码里设置MODULE_DEVICE_TABLE，指向驱动程序感兴趣的设备的设备ID列表。
