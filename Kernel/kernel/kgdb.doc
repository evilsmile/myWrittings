1. kgdb相关源码主要实现了主机上gdb远程调试所需的功能，包括命令处理、陷阱处理及串口通信3个主要部分。在2.6.26以后的内核中已在内部集成了kgdb。kgdb支持通过串口(kgdboc)和网络(kgdboe)的方式进行远程调试内核。

2. kgdb在linux内核中添加一个调试stub，调试stub是linux内核中的一小段代码，是运行gdb的开发机和目标机内核之间的媒介。gdb和调试stub之间通过gdb串行协议通信，即一种基于消息的ASCII码协议，包含了各种调试命令。当设置断点时，kgdb将断点的指令替换为一条trap指令，当执行到断点时控制权就转移到调试stub中去。此时，调试stub的任务就是使用远程串行通信协议将当前内核环境传递给gdb，然后从gdb处接收命令。gdb命令告诉调试stub下一步该做什么，当调试stub收到继续执行的命令时，将恢复内核的运行环境，把对cpu的控制权重新交还给内核。

3. kgdb功能部件由3部分组成：
   (1. GDB stub
       调试stub，kgdb调试器的核心，用来处理主机上gdb发来的各种请求，并且在内核处理被调试状态时控制目标机上的处理器。
   (2. 陷阱处理
       当设置断点时，kgdb会提供一个异常处理函数，将断点位置的指令替换成一个异常指令。执行到该断点时该异常会发生，内核则将cpu控制权交给kgdb调试器，程序进入kgdb的提供异常处理函数中。在该异常处理函数中，可以分析内核代码的各种情况。
   (3. 串口通信
       gdb和调试stub之间通过gdb串行协议进行通信，包含各种调试命令。

4. gdb远程串行协议：
   RSP是一种基于ASCII码的协议，以gdb发送命令，目标端(即kgdb)返回执行结果或信息的方式来进行，而命令和回复在传输过程中又是封装在一个包(packet)里面，每个包以一个“$”开始，接着是实际数据，数据以一个“＃”结束，后面跟着两位十六进制数字用作校验和($packet_data#checksum)。校验和需要对256取模，因为只有两位。
    当收到一个数据包，（无论是命令还是回复，无论是gdb端还是目标端）收到数据包的一方应该根据收到的数据和校验和检查这个包的合法性，如果是一个正常的包，应该返回一个“＋”，如果是一个损坏的包，则应该返回一个“-"。在包里面的数据，可以用','','';',':'三个符号来分隔成不同的段，他们的用法根据不同的命令不同而不同。
    gdb提供了一个很方便的方式让我们把通信过程记录下来，在gdb里面使用"set remotelogfile [filepath]“指定要记录的文件，但是这个文件一定要在开始记录前手动创建。
    gdb规定目标端起码应该实现：’g’ ‘G’ ‘m’ ‘M’ ‘c’ ’s’，kgdb当然也有实现了,而且还不
    止这些，有一些是和体系结构没有太紧密的关系，比如断点的设置和删除，kgdb只是记录
    起这个地址,和设置这个断点的状态；内存的读取和修改，也许这个和体系结构有关，但是
    具体实现内核已经搞定，kgdb不用关心。另外一方面一些比如’s’单步执行这种命令就和体
    系结构关系十分密切，x86上是通过设置标志寄存器的Trap标记，让cpu运行完下一条指令
    后触发一个debug中断，其他的体系结构的做法都有所不同。

    下面具体看看一些具体的命令：
    ‘g’
    格式:$g#67
    描述:gdb向目标端发送这个命令来获取目标机当前寄存器的值
    回复:+ $123456789abcdef0…#xx
    ‘+’用来应答’g'这个命令，表明目标端正确地收到这个命令，然后就是目标端的回复包,
    gdb规定用8十六进制个数字来表示一个寄存器的值,所以第一个寄存器的值为
   12345678,第二个为9abcdef0,依此类推,而具体每个寄存器的含义和寄存器个数又体系
   结构决定,定义在gdb的代码中. 当然这里8个数字是对32位系统来说的，为什么是8位?
   限于我们这个协议是基于ASCII的，一个十六进制数只能标记4位，那32位自然是8个十六进制数了。

   ‘G’
   格式:$GXXXXXXXXXXX…#xx
   描述:和g相反,这个命令用来设置目标机当前寄存器的值
   回复: + $OK#9a
   OK表示设置成功,后面我们会讲到不成功的情况.

   ‘m’
   格式:$m6a1bbb,2#b9
   描述:读取一段内存的值,这里是读取以6a1bbb位起始地址的两个字节
   回复: + $f488#0a 目标端把值返回.

   ‘M’
   格式:$Mccc5cc,2:a340#01
   描述:设置一段内存的值,这里是把以ccc5cc位开始地址的两个字节设成a340
   回复: + $OK#9a

   ’s’
   格式:$sADDR#xx
   描述:用户进行单步调试时用到,ADDR指明了程序将从那个地址恢复运行,如果忽略ADDR,程序就从断点处继续运行.
   回复:+ 目标端会马上返回数据正确或错误接收,但不会马上返回信息,具体信息要到下一次断点被触发时才会返回.下面会提到.

   ‘c’
   格式:$cADDR#xx
   描述:让程序恢复正常运行
   回复:和’s’一样.

   ‘Z’
   格式: $ZTADDR,LENGTH#xx
   ‘Z’命令用来设置断点或watch点,用过gdb的同志应该不会陌生了
   ‘T’字段定义了这个命令的对象,0:软件断点,1:硬件断点,2:写watch点,3:读watch点,4:访问watch点.
   ‘ADDR’就是我们所关心的内存地址,’LENGTH’,对于软件中断它指明被断点指令覆盖
   的内存长度,kgdb对于软件断点忽略掉它,因为触发 kgdb的指令与体系结构相关,已经定义
   在kgdb这边,就如x86的int3在内存里面的二进制指令为”0xcc”;对于硬件断点和watch 点,
   ‘LENGTH’指明gdb关注的内存长度.

   ‘z’
   格式: $zTADDR,LENGTH#xx
   各项与’Z'相同.用来取消断点。

   回复:
   错误回复:
   格式:+ $E01#a6
   描述:如果目标端在执行gdb的命令时出错时返回错误回复,比如访问内存时出错.E后面根
   两位的错误码,错误码在gdb里面没有定义,没有定义其实更加方便,可以让开发端和目标端
   对错误码的使用带来灵活.

   空回复:
   格式:+ $#00
   描述:当目标端不认识gdb发来的命令时,返回空回复表示自己不支持这个命令.

   对’c',’s’的回复:
   有好几种对’c',’s’的回复,其中比较常见的是’S'和’T’
   ‘S’
   格式: $SAA#b8
   作用: AA表明触发这次通信的那个异常相关的信号,这个信号就是posix标准中的信号.

   ‘T’
   格式: $TAAN..:R..;N..:R..#xx
   作用: AA同样是信号号, N..:R.. 这表明一个寄存器和它的值,N标记寄存器号,R是它对应的
   值,其中,如果N不是一个16进制数而是”thread”,那么后面R的值就指明当前的进程号.如果
   是其它的字符串gdb会省略.

   Kgdb在回复’s’,'c’时选用了’T'的方式,不过在’T'消息里面只有thread一个字段,没
   有给gdb传更多的寄存器信息.
   
   实现传输的两个函数为 put_packet()和 get_packet()它们的实现十分简单直接,而传输
   时使用的是底层驱动的读写操作,这部分的实现和 kgdb 没有直接的关系,kgdb 只是使用了
   现成的东西而已,这里就不罗嗦了.前面这段就是’T'回复.

